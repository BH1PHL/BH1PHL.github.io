<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta
    name="description"
    content=""
  />
  
  
    
      <title>Using the littlefs file system in RP2040&#39;s multicore mode | BH1PHL&#39;s Blog</title>
    
  
  <link rel="stylesheet" href="/css/reset.css"/>
  <link rel="stylesheet" href="/css/font.css"/>
  <link rel="stylesheet" href="/css/smigle.css"/>
  <link rel="stylesheet" href="/css/syntax.css"/>
  <link rel="stylesheet" href="/css/codecolor.css"/>
  <link rel="stylesheet" href="/css/styles.css"/>
  
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="site.webmanifest">
  <link rel="mask-icon" href="android-chrome-512x512.png" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
</head>

  <body>
    <div id="root">
      <header>
  <div id="brand">
    <a class="icon-link" href="/">
      
        <img
          class="icon"
          src="/images/china_ar.svg"
        />
      
    </a>
    <div class="text">
      <a href="/"><h1>BH1PHL&#39;s Blog</h1></a>
      
    </div>
  </div>
  <nav>
    
      
        
        <a href="/"><b>Home</b></a>
      
         | 
        <a href="/about"><b>About</b></a>
      
         | 
        <a href="/posts"><b>Posts</b></a>
      
         | 
        <a href="/tags"><b>Tags</b></a>
      
         | 
        <a href="/index.xml"><b>RSS</b></a>
      
    
    |
    
      
        <a href="/zh/posts/rp2040_multicore_littlefs/"><b>中文</b></a>
      
    
  </nav>
  <hr />
</header>

      <div id="content">
        
  <main>
    <article>
      <h1 class="title">Using the littlefs file system in RP2040&#39;s multicore mode</h1>
      
      <div class="post-meta">
  <strong>
    <span>Posted on</span>
    <time>2025-10-26</time>
    
    
  </strong>
  <span> • 433 words</span>
  <span> • 3 minute read</span>
  
  
    <div>
      <span>Tags:</span>
      
        <a href="/tags/knowledge-base">Knowledge base</a>, 
        <a href="/tags/rp2040">RP2040</a>, 
        <a href="/tags/littlefs">littlefs</a>
    </div>
  
</div>

      <div class="content"><p>The program of the RP2040 is stored in the SPI Flash, and during runtime, the program in the Flash is randomly read into the internal cache for execution. This does not pose a problem when working in single-core mode. However, in multicore mode, if one core is executing the program while another core is writing to the Flash (for example, using the <a href="https://github.com/littlefs-project/littlefs">littlefs</a> file system to manage the remaining space in the SPI Flash that does not store the program), it may cause simultaneous reading and writing of the Flash, leading to the program on one or both cores hanging.</p>
<p>In common scenarios, writing to the Flash only occurs on one core. For example, Core 0 (the default startup core) handles complex operations such as the user interface, while Core 1 is used as a digital signal processor, handling only signal chain-related tasks. In this case, the issue can be easily resolved with the following method.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;pico/multicore.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;hardware/irq.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">volatile</span> <span class="kt">int</span> <span class="n">Pause_core1</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">volatile</span> <span class="kt">int</span> <span class="n">Core1_paused</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="c1">//set as &#34;paused&#34; initially (before core 1 starts)
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//call on core1 to pause at Pause_core1
</span></span></span><span class="line"><span class="cl"><span class="c1">//must be called in a __time_critical_func
</span></span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">__time_critical_func</span><span class="p">(</span><span class="n">core1_pause</span><span class="p">)(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">Pause_core1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">s</span><span class="o">=</span><span class="nf">save_and_disable_interrupts</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">Core1_paused</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">Pause_core1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="nf">tight_loop_contents</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Necessary re-init codes for resume processing here
</span></span></span><span class="line"><span class="cl">        <span class="c1">// .........
</span></span></span><span class="line"><span class="cl">        <span class="c1">// .........
</span></span></span><span class="line"><span class="cl">        <span class="nf">restore_interrupts_from_disabled</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">Core1_paused</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>   
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//call on core0 to stop core1
</span></span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">core1_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">Pause_core1</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>   <span class="c1">//pause core1
</span></span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">Core1_paused</span><span class="p">){</span>    <span class="c1">//wait until core1 paused
</span></span></span><span class="line"><span class="cl">        <span class="nf">tight_loop_contents</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//call on core0 to resume core1
</span></span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">core1_resume</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">Pause_core1</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>   <span class="c1">//resume core1
</span></span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//core1_process() must be a __time_critical_func
</span></span></span><span class="line"><span class="cl"><span class="c1">//but it can call normal xip functions
</span></span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">__time_critical_func</span><span class="p">(</span><span class="n">core1_process</span><span class="p">)(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	    <span class="c1">// ... Signal processing codes ...
</span></span></span><span class="line"><span class="cl">	    <span class="c1">// ...............................
</span></span></span><span class="line"><span class="cl">	    <span class="c1">// ...............................
</span></span></span><span class="line"><span class="cl">	    <span class="nf">core1_pause</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//call on core0 to launch core1_process
</span></span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">core1_launch</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="n">Core1_paused</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">multicore_launch_core1</span><span class="p">(</span><span class="n">core1_process</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Before writing to the Flash, use <code>core1_stop()</code> to pause the operation of Core 1, and after writing to the Flash, use <code>core1_resume()</code> to resume the operation of Core 1. This allows for safe writing to the Flash. For example (modified from <a href="https://mkusunoki.net/?p=8196">here</a>):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">pico_flash_prog</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">lfs_config</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">lfs_block_t</span> <span class="n">block</span><span class="p">,</span> <span class="kt">lfs_off_t</span> <span class="n">off</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="kt">lfs_size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">LFS_ASSERT</span><span class="p">(</span><span class="n">block</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">block_count</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// program with SDK
</span></span></span><span class="line"><span class="cl">    <span class="nf">core1_stop</span><span class="p">();</span>    <span class="c1">// stop core1 when writing to flash (read is OK)    
</span></span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">FS_BASE</span> <span class="o">+</span> <span class="p">(</span><span class="n">block</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">block_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">off</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">ints</span> <span class="o">=</span> <span class="nf">save_and_disable_interrupts</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nf">flash_range_program</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">restore_interrupts</span><span class="p">(</span><span class="n">ints</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">core1_resume</span><span class="p">();</span>	<span class="c1">// resume core1
</span></span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">LFS_ERR_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">pico_flash_erase</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">lfs_config</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">lfs_block_t</span> <span class="n">block</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">LFS_ASSERT</span><span class="p">(</span><span class="n">block</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">block_count</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// erase with SDK
</span></span></span><span class="line"><span class="cl">    <span class="nf">core1_stop</span><span class="p">();</span>    <span class="c1">// stop core1 when writing to flash (read is OK)    
</span></span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">FS_BASE</span> <span class="o">+</span> <span class="n">block</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">block_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">ints</span> <span class="o">=</span> <span class="nf">save_and_disable_interrupts</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nf">flash_range_erase</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">block_size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">restore_interrupts</span><span class="p">(</span><span class="n">ints</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">core1_resume</span><span class="p">();</span>	<span class="c1">//resume core1
</span></span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">LFS_ERR_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></div>
    </article>
  </main>

      </div>
      <footer>
  <hr />
  
    <p id="social">
      Find me around the web:
      <br />
      
        
        <a href="mailto:bh1phl%20[at]%20hotmail.com">email</a>
      
         | 
        <a href="http://www.qrz.com/db/BH1PHL">qrz.com</a>
      
         | 
        <a href="https://qsl.net/bh1phl">qsl.net</a>
      
         | 
        <a href="https://bh1phl.github.io">github.io</a>
      
    </p>
  
  <p class="copyright">
    Copyright © 2014-2026
    <a href="/"><strong>BH1PHL</strong></a>.
    Licensed under the
    <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> license unless otherwise noted.<br>May contain LLM-translated-and-human-proofread materials.
  </p>
  <p class="builtWith">
    Built with
    <a href="http://www.gohugo.io/">Hugo</a>,
    using the theme
    <a href="https://gitlab.com/ian-s-mcb/smigle-hugo-theme">smigle</a>,
    which was influenced by the theme
    <a href="https://github.com/sumnerevans/smol">smol</a>.
  </p>
  <script>
    
    if (!(/(qsl.net)|(github.io)/.test(window.location.host)))
        window.goatcounter = {no_onload: true}
  </script>
  <script data-goatcounter="https://bh1phl.goatcounter.com/count"
    async src="https://qsl.net/bh1phl/count.js"></script>
</footer>

    </div>
  </body>
</html>
