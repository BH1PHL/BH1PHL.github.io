<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta
    name="description"
    content=""
  />
  
  
    
      <title>Forth 语言基础（一） | BH1PHL 的 Blog</title>
    
  
  <link rel="stylesheet" href="/css/reset.css"/>
  <link rel="stylesheet" href="/css/font.css"/>
  <link rel="stylesheet" href="/css/smigle.css"/>
  <link rel="stylesheet" href="/css/syntax.css"/>
  <link rel="stylesheet" href="/css/codecolor.css"/>
  <link rel="stylesheet" href="/css/styles.css"/>
  
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="site.webmanifest">
  <link rel="mask-icon" href="android-chrome-512x512.png" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
</head>

  <body>
    <div id="root">
      <header>
  <div id="brand">
    <a class="icon-link" href="/zh/">
      
        <img
          class="icon"
          src="/images/china_ar.svg"
        />
      
    </a>
    <div class="text">
      <a href="/zh/"><h1>BH1PHL 的 Blog</h1></a>
      
    </div>
  </div>
  <nav>
    
      
        
        <a href="/zh/"><b>Home</b></a>
      
         | 
        <a href="/zh/about"><b>About</b></a>
      
         | 
        <a href="/zh/posts"><b>Posts</b></a>
      
         | 
        <a href="/zh/tags"><b>Tags</b></a>
      
         | 
        <a href="/zh/index.xml"><b>RSS</b></a>
      
    
    |
    
      
        <a href="/"><b>English</b></a>
      
	
  </nav>
  <hr />
</header>

      <div id="content">
        
  <main>
    <article>
      <h1 class="title">Forth 语言基础（一）</h1>
      
      <div class="post-meta">
  <strong>
    <span>Posted on</span>
    <time>2025-01-24</time>
    
    
  </strong>
  <span> • 31251 words</span>
  <span> • 63 minute read</span>
  
  
    <div>
      <span>Tags:</span>
      
        <a href="/zh/tags/my4th">My4TH</a>, 
        <a href="/zh/tags/forth">Forth</a>
    </div>
  
</div>

      <div class="content"><h2 id="目的">目的</h2>
<p>本文的目的是以 My4TH Forth 为例，用<strong>尽量少的</strong>篇幅<strong>尽可能全面地</strong>介绍 Forth 语言。</p>
<p>本文拟分为若干部分。本部分为第一部分，完整介绍了 Forth 语言本身，Forth 2012 标准中 Core、Core Extension、Block、Double-Number 等几个最基本的词集的内容，以及 My4TH Forth 部分扩展词的内容。这一部分的例子都可实际运行，在 My4TH Forth 上验证。</p>
<p>本文按 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode.zh-hans">CC BY-<strong>NC</strong>-SA 4.0</a> 协议发布。</p>
<h2 id="需要的基础知识">需要的基础知识</h2>
<p>阅读本文前，需要有一点关于算法与数据结构的基本常识（文中不会再去解释什么叫栈、什么叫链表），对计算机的体系结构有最基本的理解，最好用至少一种汇编语言编写过程序。</p>
<p>读者不必须使用过其他高级语言。但是如果了解传统的编译型高级语言的实现细节，对理解 Forth 系统的底层会大有帮助（推荐阅读《C/C++ 深层探索》和《链接器和加载器（Linkers and Loaders）》）。</p>
<p>读者有一点（自然语言的）语言学常识当然更好。不过这也不是必需的。</p>
<h2 id="forth-的基本结构">Forth 的基本结构</h2>
<p>形式化地说，<strong>Forth 是一个拥有 两个栈<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> 和 一片可动态分配的内存区域 的虚拟机</strong>。两个栈中，一个用来暂存计算中的数据，一般称作数据栈（data stack）、参数栈（parameter stack），或直接称作<strong>栈</strong>（stack）；另一个用来暂存返回地址及某些数据（如循环中的循环变量），一般称作<strong>返回栈</strong>（return stack；某些文献中简写为 rstack）。栈中的一个<strong>单元</strong>（cell）的大小一般至少为 16 位（2 个字节）。</p>
<p>可动态分配的内存区域用来存储变量及程序等，称作<strong>词典</strong>（dictionary）。词典中的项目（如变量和程序）称作<strong>定义</strong>（definition），定义的名称称作<strong>词</strong><sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>（word）。 大部分 Forth 解释器中，词不分大小写（但标准对大小写敏感性未进行强制规定）。</p>
<p>需要注意的是，为了方便实现，实际的 Forth 解释器可能会在物理上用更多的栈来实现相同的逻辑功能。如 My4TH Forth 中，有两个单独的栈来处理控制流和循环，<code>R&gt;</code> 和 <code>&gt;R</code> 访问的“返回栈”和存储循环变量（如 <code>I</code> 和 <code>J</code> ）的“返回栈”，在物理上也不是同一个（详见<a href="http://mynor.org/my4th_forth.htm">这里</a>）。</p>
<h2 id="表达式的计算">表达式的计算</h2>
<p>Forth 使用后缀表达式（逆波兰表达式）进行计算。例如，计算 <code>1+2</code> 时，需要使用如下指令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">2</span> <span class="k">+ </span><span class="kt">.</span><span class="nf">↵</span>
</span></span></code></pre></div><p>解释器以空格为分隔符，从左向右解释输入序列。遇到一个<strong>记号</strong>（token）时，解释器先在词典中查找它，如果找到则执行它；如果词典中没找到这个记号，则解释器试图将其作为数字解释，成功时将数字压入栈内，不成功时报错。</p>
<p>执行上面的指令时，解释器首先将 <code>1</code> 压入栈内，然后将 <code>2</code> 压入栈内。<code>+</code> 是一个词，其作用是弹出栈顶的两个元素，并将其和压入栈内。<code>.</code> 也是一个词，用于弹出并打印栈顶的内容。因此，上面指令的输出是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">3</span>  <span class="nf">ok</span>
</span></span></code></pre></div><p><code>ok</code>  是 My4TH Forth 解释器的提示符。</p>
<p><code>.S</code> 用于打印栈内的全部内容（最右侧内容是栈顶）。如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="kt">.</span><span class="nf">s↵</span> <span class="nf">&lt;3&gt;</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>  <span class="nf">ok</span>
</span></span></code></pre></div><p>输出的 <code>&lt;3&gt;</code> 是栈深（栈内元素的总个数）。注意 <code>.S</code> 不会改变栈的内容，而 <code>.</code> 在打印的同时会弹出栈顶元素。</p>
<p><code>CR</code> 用于换行。如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">3</span> <span class="mi">4</span> <span class="k">+ </span><span class="mi">5</span> <span class="mi">2</span> <span class="k">- * </span><span class="mi">3</span> <span class="mi">3</span> <span class="mi">1</span> <span class="k">+ + / cr </span><span class="kt">.</span><span class="nf">↵</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span>  <span class="nf">ok</span>
</span></span></code></pre></div><p>这段程序计算的表达式是 <code>(3+4)*(5-2)/(3+1+3)</code>。</p>
<h3 id="数字的输入方式">数字的输入方式</h3>
<h4 id="单精度整数与双精度整数">单精度整数与双精度整数</h4>
<p>My4TH Forth 原生支持<strong>单精度整数</strong>（在栈中占 1 个单元）和<strong>双精度整数</strong>（在栈中占 2 个单元）。输入单精度整数时，直接输入数字本身即可：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">1</span> <span class="kt">.</span><span class="nf">s↵</span> <span class="nf">&lt;1&gt;</span> <span class="mi">1</span>  <span class="nf">ok</span>
</span></span></code></pre></div><p>输入双精度整数时，需要在数字后面加 <code>.</code>，如 <code>100000.</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">100000</span><span class="k">. </span><span class="kt">.</span><span class="nf">s↵</span> <span class="nf">&lt;2&gt;</span> <span class="mi">-31072</span> <span class="mi">1</span>  <span class="nf">ok</span>
</span></span></code></pre></div><p>（-31072<sub>10</sub>=86a0<sub>16</sub>，186a0<sub>16</sub>=100000<sub>10</sub>。）</p>
<p>打印双精度整数使用 <code>D.</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">100000</span><span class="k">. </span><span class="nf">d.↵</span> <span class="mi">100000</span>  <span class="nf">ok</span>
</span></span></code></pre></div><p>将单精度整数转换为双精度整数使用 <code>S&gt;D</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">10000</span> <span class="k">s&gt;d </span><span class="nf">d.↵</span> <span class="mi">10000</span>  <span class="nf">ok</span>
</span></span></code></pre></div><p>将双精度整数转换为单精度整数使用 <code>D&gt;S</code>。注意此时双精度整数的值应在单精度整数可表示的范围内。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">10000</span><span class="k">. d&gt;s </span><span class="kt">.</span><span class="nf">↵</span> <span class="mi">10000</span>  <span class="nf">ok</span>
</span></span></code></pre></div><h4 id="无符号整数与有符号整数">无符号整数与有符号整数</h4>
<p>在 Forth 中，数据类型由执行的程序决定，解释器本身同等对待无符号整数和有符号整数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">-1</span> <span class="kt">.</span><span class="nf">↵</span> <span class="mi">-1</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">65535</span> <span class="kt">.</span><span class="nf">↵</span> <span class="mi">-1</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">-1</span> <span class="kt">.</span><span class="nf">s↵</span> <span class="nf">&lt;1&gt;</span> <span class="mi">-1</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">65535</span> <span class="kt">.</span><span class="nf">s↵</span> <span class="nf">&lt;2&gt;</span> <span class="mi">-1</span> <span class="mi">-1</span>  <span class="nf">ok</span>
</span></span></code></pre></div><p>打印无符号整数时，需要使用 <code>U.</code> 而不是 <code>.</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">60000</span> <span class="kt">.</span><span class="nf">↵</span> <span class="mi">-5536</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">60000</span> <span class="nf">u.↵</span> <span class="mi">60000</span>  <span class="nf">ok</span>
</span></span></code></pre></div><p>显然，无符号整数和有符号整数使用同一套算术运算词（除少数词以外，如两个单精度整数相乘得一个双精度整数的 <code>M*</code> 与 <code>UM*</code>，以及双精度整数除以单精度整数的 <code>FM/MOD</code>、<code>SM/REM</code> 和 <code>UM/MOD</code>）。</p>
<h4 id="不同进制的整数">不同进制的整数</h4>
<p>Forth 解释器可处理不同进制的整数。在缺省状态下，数字为十进制。</p>
<p>具有前缀 <code>#</code>、<code>$</code>、<code>%</code> 的数字分别为十进制、十六进制、二进制：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">#10</span> <span class="kt">.</span><span class="nf">↵</span> <span class="mi">10</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mh">$10</span> <span class="kt">.</span><span class="nf">↵</span> <span class="mi">16</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">%10</span> <span class="kt">.</span><span class="nf">↵</span> <span class="mi">2</span>  <span class="nf">ok</span>
</span></span></code></pre></div><p>为增加可读性，数字中可自由插入 <code>_</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">10</span><span class="nf">_00_0</span> <span class="kt">.</span><span class="nf">↵</span> <span class="mi">10000</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mh">$0f</span><span class="nf">_ff</span> <span class="kt">.</span><span class="nf">↵</span> <span class="mi">4095</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">%0</span><span class="nf">_01_0_1_0_1_1</span> <span class="kt">.</span><span class="nf">↵</span> <span class="mi">43</span>  <span class="nf">ok</span>
</span></span></code></pre></div><p><code>HEX</code> 可将解释器缺省的数制切换至十六进制；<code>DECIMAL</code> 可将缺省的数制切换回十进制：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">10</span><span class="nf">↵</span>  <span class="nf">ok</span>		<span class="c1">\ 栈内压入十进制的 10
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">hex↵</span>  <span class="nf">ok</span>		<span class="c1">\ 将解释器切换至十六进制
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">.</span><span class="nf">↵</span> <span class="nf">A</span>  <span class="nf">ok</span>		<span class="c1">\ . 打印出的数字为十六进制
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">a</span> <span class="kt">.</span><span class="nf">↵</span> <span class="nf">A</span>  <span class="nf">ok</span>		<span class="c1">\ 此时输入和打印的均为十六进制的整数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">#11</span> <span class="kt">.</span><span class="nf">↵</span> <span class="nf">B</span>  <span class="nf">ok</span>	<span class="c1">\ 前缀 #、$、% 此时仍可用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">10</span><span class="nf">↵</span>  <span class="nf">ok</span>		<span class="c1">\ 栈内压入十六进制的 10
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">decimal↵</span>  <span class="nf">ok</span>	<span class="c1">\ 切换至十进制
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">. </span><span class="mi">16</span><span class="nf">↵</span>  <span class="nf">ok</span>		<span class="c1">\ . 打印出的数字为十进制
</span></span></span></code></pre></div><h2 id="注释的写法及文档中栈的表示法">注释的写法，及文档中栈的表示法</h2>
<p>Forth 的注释有两种写法：<code>\</code> 和 <code>(</code>&hellip;<code>)</code>。解释器遇到 <code>\</code> 时，会忽略本行后面的所有内容；遇到 <code>(</code> 时，会忽略 <code>(</code> 和下一个 <code>)</code> 之间的所有内容。注意 <code>\</code> 和 <code>(</code> 都是词，它们的前后都必须有空格（<code>)</code>前不必须有空格）。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">2</span> <span class="k">+ cr . cr </span><span class="c1">\ Calculate 1+2.↵
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">3</span>
</span></span><span class="line"><span class="cl"> <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">2</span> <span class="k">+ </span><span class="c1">( Calculate 1+2.)</span> <span class="k">cr . </span><span class="nf">cr↵</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span>
</span></span><span class="line"><span class="cl"> <span class="nf">ok</span>
</span></span></code></pre></div><p>文档中说明某个词对栈的内容产生的作用时，一般使用如下的<strong>栈表示法</strong>（stack notation）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="c1">( before -- after )</span>
</span></span></code></pre></div><p><code>before</code> 表示执行这一词对应的操作前栈的内容，<code>after</code> 表示执行这一词对应的操作后栈的内容。其中的 <code>--</code> 在有的文档中写作 <code>→</code>、<code>——</code> 或 <code>---</code> 等。如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">+ </span><span class="c1">( n1 n2 -- sum )</span> 	<span class="c1">\ 将 n1 与 n2 从栈内弹出，求和，并将和压入栈内。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">. </span><span class="c1">( n -- )</span>			<span class="c1">\ 从栈内弹出一个数，并打印，然后打印一个空格。
</span></span></span></code></pre></div><p>由于“弹出”和“压入”在栈表示法中是显然的（如果一项包含在 <code>--</code> 前面的内容中，但不包含在 <code>--</code> 后面的内容中，那么它就被弹出了），所以注释中通常不包含弹出和压入的内容（压入的内容有时称作<strong>返回值</strong>）。如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">+ </span><span class="c1">( n1 n2 -- sum )</span> 	<span class="c1">\ 返回 n1 与 n2 之和。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">. </span><span class="c1">( n -- )</span> 			<span class="c1">\ 打印一个数，然后打印一个空格。
</span></span></span></code></pre></div><p>要注意，在所有的 Forth 文档中，当将栈的内容横写时，<strong>最右侧内容总是栈顶</strong>。如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">- </span><span class="c1">( n1 n2 -- n3 )</span>	<span class="c1">\ n3=n1-n2.
</span></span></span></code></pre></div><p>上例中，<code>n2</code> 是操作 <code>-</code> 进行前的栈顶内容。所以计算 <code>32-23</code> 使用的指令为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">32</span> <span class="mi">23</span> <span class="k">- </span><span class="kt">.</span><span class="nf">↵</span> <span class="mi">9</span>  <span class="nf">ok</span>
</span></span></code></pre></div><p>下面给出一个比较复杂的例子。 词 <code>/MOD</code> 的作用是计算商和余数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">/MOD </span><span class="c1">( n1 n2 -- n3 n4 )</span>	<span class="c1">\ n3=n1 mod n2, n4=n1/n2.
</span></span></span></code></pre></div><p>指令 <code>3 4 + 5 2 - * 2 5 * /mod cr . .</code> 的执行过程可表示如下（为清晰起见，省略掉 <code>before</code> 和 <code>--</code>）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="nf">命令行成员</span>	<span class="nf">栈</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span>			<span class="c1">( 3 )</span>
</span></span><span class="line"><span class="cl"><span class="mi">4</span>			<span class="c1">( 3 4 )</span>
</span></span><span class="line"><span class="cl"><span class="k">+	</span>		<span class="c1">( 7 )</span>
</span></span><span class="line"><span class="cl"><span class="mi">5</span>			<span class="c1">( 7 5 )</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span>			<span class="c1">( 7 5 2 )</span>
</span></span><span class="line"><span class="cl"><span class="k">-	</span>		<span class="c1">( 7 3 )</span>	
</span></span><span class="line"><span class="cl"><span class="k">*	</span>		<span class="c1">( 21 )</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span>			<span class="c1">( 21 2 )</span>
</span></span><span class="line"><span class="cl"><span class="mi">5</span>			<span class="c1">( 21 2 5 )</span>
</span></span><span class="line"><span class="cl"><span class="k">*	</span>		<span class="c1">( 21 10 )</span>	
</span></span><span class="line"><span class="cl"><span class="k">/mod	</span>	<span class="c1">( 1 2 )</span>
</span></span><span class="line"><span class="cl"><span class="k">cr	</span>		<span class="c1">( 1 2 )</span>
</span></span><span class="line"><span class="cl"><span class="k">.	</span>		<span class="c1">( 1 )</span>
</span></span><span class="line"><span class="cl"><span class="k">.	</span>		<span class="c1">( )</span>
</span></span></code></pre></div><p>故其执行结果为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">3</span> <span class="mi">4</span> <span class="k">+ </span><span class="mi">5</span> <span class="mi">2</span> <span class="k">- * </span><span class="mi">2</span> <span class="mi">5</span> <span class="k">* /mod cr . </span><span class="kt">.</span><span class="nf">↵</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="mi">1</span>  <span class="nf">ok</span>
</span></span></code></pre></div><p>本文档中会广泛使用栈表示法来描述一个词及其执行过程。</p>
<p>栈表示法中元素的符号，一般采用如下约定：</p>
<table>
  <thead>
      <tr>
          <th>符号</th>
          <th>意义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>n</code></td>
          <td>有符号整数；一般的占 1 个单元的元素（有时用 x 表示）</td>
      </tr>
      <tr>
          <td><code>+n</code></td>
          <td>正整数（大于 0 的整数）</td>
      </tr>
      <tr>
          <td><code>u</code></td>
          <td>无符号整数</td>
      </tr>
      <tr>
          <td><code>c</code>,<code>char</code></td>
          <td>字符</td>
      </tr>
      <tr>
          <td><code>f</code>,<code>flag</code></td>
          <td>标志，取值为真（<code>true</code>，非零）/假（<code>false</code>，零）</td>
      </tr>
      <tr>
          <td><code>addr</code></td>
          <td>地址</td>
      </tr>
      <tr>
          <td><code>a-addr</code></td>
          <td>按单元对齐的地址</td>
      </tr>
      <tr>
          <td><code>c-addr</code></td>
          <td>按字符对齐的地址</td>
      </tr>
      <tr>
          <td><code>xt</code></td>
          <td>执行标记（execution token），在大部分 Forth 系统中占 1 个单元，对应一个词执行时的行为</td>
      </tr>
      <tr>
          <td><code>d</code></td>
          <td>双精度有符号整数；一般的占 2 个单元的元素</td>
      </tr>
      <tr>
          <td><code>ud</code></td>
          <td>双精度无符号整数</td>
      </tr>
  </tbody>
</table>
<h2 id="基本的栈操作">基本的栈操作</h2>
<p>基本的栈操作用到的词如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="nf">单精度元素的栈操作：</span>
</span></span><span class="line"><span class="cl"><span class="k">DUP	</span>	<span class="c1">( n -- n n )</span>		<span class="c1">\ 复制栈顶元素。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">DROP	</span><span class="c1">( n -- )</span>			<span class="c1">\ 抛弃栈顶元素。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SWAP	</span><span class="c1">( a b -- b a )</span>		<span class="c1">\ 交换栈顶的两个元素。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">OVER	</span><span class="c1">( a b -- a b a )</span>	<span class="c1">\ 将栈内第二项元素复制到栈顶。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">ROT	</span>	<span class="c1">( a b c -- b c a )</span>	<span class="c1">\ 将栈内第三项元素移动到栈顶。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">-ROT</span>	<span class="c1">( a b c -- c a b )</span>	<span class="c1">\ 将栈顶元素移动到栈内第三项（ROT 的逆操作）。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">PICK	</span><span class="c1">( .. n2 n1 n0 index -- .. n0 n_index )</span>	<span class="c1">\ 复制栈内第 index 项元素到栈顶。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">ROLL	</span><span class="c1">( .. n2 n1 n0 index -- .. n0 n_index )</span>	<span class="c1">\ 将栈内第 index 项元素移动到栈顶。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">NIP	</span>	<span class="c1">( a b -- b )</span>		<span class="c1">\ 抛弃栈内第二项元素。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">TUCK	</span><span class="c1">( a b -- b a b )</span>	<span class="c1">\ 将栈顶元素复制为栈内第三项。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nf">双精度元素的栈操作：</span>
</span></span><span class="line"><span class="cl"><span class="k">2DUP	</span><span class="c1">( d -- d d )</span>
</span></span><span class="line"><span class="cl"><span class="k">2DROP	</span><span class="c1">( d -- )</span>
</span></span><span class="line"><span class="cl"><span class="k">2SWAP	</span><span class="c1">( da db -- db da )</span>
</span></span><span class="line"><span class="cl"><span class="k">2OVER	</span><span class="c1">( da db -- da db da )</span>
</span></span><span class="line"><span class="cl"><span class="k">2ROT	</span><span class="c1">( da db dc -- db dc da )</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">下面两个词除在调试程序时之外，很少使用：</span>
</span></span><span class="line"><span class="cl"><span class="k">DEPTH	</span><span class="c1">( a1 a2 ... an -- a1 a2 .. an n )</span>	<span class="c1">\ 获得栈深。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">.S	</span><span class="c1">( [s] -- [s] )</span>			<span class="c1">\ 打印栈内所有元素（不弹出）。
</span></span></span></code></pre></div><p>显然，这些词中有些词可用其他的词代替，如 <code>NIP</code> 与 <code>SWAP DROP</code> 等价， <code>TUCK</code> 与 <code>SWAP OVER</code> 等价。如果一个 Forth 系统没有其中的某些词，可以——</p>
<h2 id="定义新词">定义新词</h2>
<h3 id="冒号定义">冒号定义</h3>
<p>定义新词最常使用的词是 <code>:</code> 和 <code>;</code>。这种定义方式称作<strong>冒号定义</strong> (colon definition)：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">w</span>		<span class="c1">( -- )</span> 	<span class="c1">\ 开始对新词 w 的定义。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">;	</span>	<span class="c1">( -- )</span>	<span class="c1">\ 结束一个词的定义。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">\ 下面三个词用在冒号定义中，用于在运行定义的词时提前退出当前词对应的程序，
</span></span></span><span class="line"><span class="cl"><span class="c1">\ 常与分支结构结合使用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">EXIT	</span><span class="c1">( -- )</span>	<span class="c1">\ 退出当前程序。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="c1">\ 该词在 DO...LOOP 循环里使用时，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="c1">\ 需要先用词 UNLOOP 将循环变量抛弃。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">ABORT	</span><span class="c1">( -- )</span>	<span class="c1">\ 中止当前程序，清空栈和返回栈，退回到解释器。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">ABORT&#34; </span><span class="nf">string&#34;</span>	<span class="c1">( f -- )</span>	<span class="c1">\ 如果 f 为 true（非零），
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="c1">\ 则打印 string，然后执行 ABORT 中止当前程序；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="c1">\ 如果 f 为 false（零），则不进行任何操作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">\ 下面三个词用于维护词典。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">FORGET </span><span class="nf">w</span>	<span class="c1">( -- )</span>	<span class="c1">\ 删除词 w 及在其之后定义的所有词。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">\ 如果词典中有多个名为 w 的词，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">\ 则删除最后一个 w 及在其之后定义的所有词。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">MARKER </span><span class="nf">mw</span>	<span class="c1">( -- )</span>	<span class="c1">\ 定义一个名为 mw 的标记词。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">\ 执行 mw 时，删除 mw 本身及在其之后定义的所有词。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">WORDS	</span>	<span class="c1">( -- )</span>	<span class="c1">\ 查看目前定义的词
</span></span></span></code></pre></div><p>冒号定义中，新词的名称 <code>w</code> 紧接着 <code>:</code> 出现；定义结束后，执行 <code>w</code> 的效果等同于执行定义时 <code>w</code> 后面的词序列的效果。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">nip2</span>  <span class="k">swap drop </span><span class="nf">;↵</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">tuck2</span>  <span class="k">swap over </span><span class="nf">;↵</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">\ 定义之后，这两个词可以使用，与标准的 NIP 和 TUCK 完全相同：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">1</span> <span class="mi">2</span> <span class="kt">.</span><span class="nf">s↵</span> <span class="nf">&lt;2&gt;</span> <span class="mi">1</span> <span class="mi">2</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="k">nip </span><span class="kt">.</span><span class="nf">s↵</span> <span class="nf">&lt;1&gt;</span> <span class="mi">2</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="kt">.</span><span class="nf">↵</span> <span class="mi">2</span>  <span class="nf">ok</span>	<span class="c1">\ 清空栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">1</span> <span class="mi">2</span> <span class="kt">.</span><span class="nf">s↵</span> <span class="nf">&lt;2&gt;</span> <span class="mi">1</span> <span class="mi">2</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="nf">nip2</span> <span class="kt">.</span><span class="nf">s↵</span> <span class="nf">&lt;1&gt;</span> <span class="mi">2</span>  <span class="nf">ok</span>	<span class="c1">\ nip2 与 nip 作用完全相同
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">.</span><span class="nf">↵</span> <span class="mi">2</span>  <span class="nf">ok</span>	<span class="c1">\ 清空栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="kt">.</span><span class="nf">s↵</span> <span class="nf">&lt;3&gt;</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="k">tuck </span><span class="kt">.</span><span class="nf">s↵</span> <span class="nf">&lt;4&gt;</span> <span class="mi">1</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">3</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="k">. . . </span><span class="kt">.</span><span class="nf">↵</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">1</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="kt">.</span><span class="nf">s↵</span> <span class="nf">&lt;3&gt;</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="nf">tuck2</span> <span class="kt">.</span><span class="nf">s↵</span> <span class="nf">&lt;4&gt;</span> <span class="mi">1</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">3</span>  <span class="nf">ok</span>	<span class="c1">\ tuck2 与 tuck 作用完全相同
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">. . . </span><span class="kt">.</span><span class="nf">↵</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">1</span>  <span class="nf">ok</span>
</span></span></code></pre></div><p>定义词时可以任意换行。在定义状态下换行时，提示符 <code>ok</code> 会变为 <code>compiled</code>，以提示用户正在定义词：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">*.↵</span>  <span class="nf">compiled</span>
</span></span><span class="line"><span class="cl"><span class="nf">*↵</span>  <span class="nf">compiled</span>
</span></span><span class="line"><span class="cl"><span class="kt">.</span><span class="nf">↵</span>  <span class="nf">compiled</span>
</span></span><span class="line"><span class="cl"><span class="nf">;↵</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span> <span class="mi">2</span> <span class="nf">*.</span> <span class="mi">6</span><span class="nf">↵</span>  <span class="nf">ok</span>
</span></span></code></pre></div><p>正如上例中所显示的，词的名称可以包含符号。词可以重名，执行时，解释器会执行<strong>最新</strong>定义的词。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="nf">test↵</span>  <span class="nf">?</span> <span class="nf">unknown</span> <span class="k">word </span><span class="nf">test</span>
</span></span><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">test</span>  <span class="s">.&#34;</span> <span class="s">Test1</span><span class="nf">&#34;</span> <span class="k">cr </span><span class="nf">;↵</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="nf">test↵</span> <span class="nf">Test1</span>
</span></span><span class="line"><span class="cl"> <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">test</span>  <span class="s">.&#34;</span> <span class="s">Test2</span><span class="nf">&#34;</span> <span class="k">cr </span><span class="nf">;↵</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="nf">test↵</span> <span class="nf">Test2</span>
</span></span><span class="line"><span class="cl"> <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">test</span>  <span class="s">.&#34;</span> <span class="s">Test3</span><span class="nf">&#34;</span> <span class="k">cr </span><span class="nf">;↵</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="nf">test↵</span> <span class="nf">Test3</span>
</span></span><span class="line"><span class="cl"> <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="nf">words↵</span>
</span></span><span class="line"><span class="cl"><span class="nf">[</span> <span class="nf">]</span> <span class="nf">&#39;</span> <span class="k">@ ! &lt; &gt; </span><span class="nf">=</span> <span class="k">+ - * / . </span><span class="nf">?</span> <span class="k">, i j </span><span class="nf">k</span> <span class="nf">l</span> <span class="k"># </span><span class="kn">:</span> <span class="nc">;</span> <span class="k">immediate 2constant
</span></span></span><span class="line"><span class="cl"><span class="k"></span><span class="kt">...</span> 
</span></span><span class="line"><span class="cl"><span class="nf">i2c-recv</span> <span class="nf">ch453-wr</span> <span class="nf">ctrloutp</span> <span class="nf">terminal</span> <span class="nf">test</span> <span class="nf">test</span> <span class="nf">test</span>
</span></span><span class="line"><span class="cl"> <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="k">forget </span><span class="nf">test↵</span>  <span class="nf">ok</span>			<span class="c1">\ 删除最后定义的那个 test
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">test↵</span> <span class="nf">Test2</span>
</span></span><span class="line"><span class="cl"> <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="k">forget </span><span class="nf">test</span> <span class="nf">test↵</span> <span class="nf">Test1</span>	<span class="c1">\ forget test 和 test 之间没有回车也可以。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="c1">\ 回车的作用只是告诉解释器解释输入的一行，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="c1">\ 并无空白之外的语法作用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="k">forget </span><span class="nf">test</span> <span class="nf">test↵</span>  <span class="nf">?</span> <span class="nf">unknown</span> <span class="k">word </span><span class="nf">test</span>
</span></span></code></pre></div><p>其中，词 <code>.&quot;</code> 的作用是打印跟在后面，直到下一个 <code>&quot;</code> 的字符。</p>
<p>可以使用数字作为词的名称。此时解释器遵循前面已经介绍过的行为：<strong>先在词典中查找，找不到时再试图解释数字。</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">1</span>  <span class="mi">1</span> <span class="k">. </span><span class="nf">;↵</span>  <span class="nf">ok</span>		<span class="c1">\ 冒号定义中的 “1” 仍然是数字
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">1</span><span class="nf">↵</span> <span class="mi">1</span>  <span class="nf">ok</span>				<span class="c1">\ 此时的 “1” 已经是一个词
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">1</span> <span class="mi">2</span> <span class="k">+ </span><span class="kt">.</span><span class="nf">↵</span> <span class="mi">1</span>  <span class="nf">?</span> <span class="nf">stack</span>	<span class="c1">\ 解释器将 “1” 作为词而不是数字使用，因此打印出了一个 1；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>						<span class="c1">\ 到 + 时，栈内元素数不够了，因此报错。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">forget </span><span class="mi">1</span><span class="nf">↵</span>  <span class="nf">ok</span>			<span class="c1">\ 删除词 “1”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">1</span> <span class="mi">2</span> <span class="k">+ </span><span class="kt">.</span><span class="nf">↵</span> <span class="mi">3</span>  <span class="nf">ok</span>			<span class="c1">\ “1” 恢复成了数字。
</span></span></span></code></pre></div><p>有时常常需要递归定义（在一个冒号定义的词里面调用它自己）。然而，从上面数字的例子可以看出。冒号定义尚未结束时无法用词名引用正在定义的词本身。此时需要用 <code>RECURSE</code> 引用词本身<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">RECURSE	</span><span class="c1">( ... -- ... )</span>	<span class="c1">\ 引用正在定义的词本身。
</span></span></span></code></pre></div><p>例如最经典的计算阶乘的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">factorial</span> <span class="c1">( +n1 -- +n2 )</span>
</span></span><span class="line"><span class="cl">   <span class="k">dup </span><span class="mi">2</span> <span class="k">&lt; if </span>			<span class="c1">\ 如果 +n1&lt;2（=1）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">drop </span><span class="mi">1</span> <span class="k">exit	</span>	<span class="c1">\ 则返回值为 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">then	</span>				<span class="c1">\ （THEN 可理解为 END IF）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">dup 1- recurse *	;	</span><span class="c1">\ 否则返回值为：+n1 乘以 (+n1-1) 的阶乘
</span></span></span></code></pre></div><h3 id="常量与变量的定义和使用">常量与变量的定义和使用</h3>
<p>常量、变量和值也是词。定义常量使用的词是 <code>CONSTANT</code><sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">CONSTANT</span> <span class="nc">name</span>	<span class="c1">( n -- )</span>	<span class="c1">\ 定义一个名为 name 的常量。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="c1">\ 执行 name 时，会在栈中压入数字 n。
</span></span></span></code></pre></div><p>如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">1000</span> <span class="kn">constant</span> <span class="nc">thousand↵</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="nf">thousand</span> <span class="mi">1</span> <span class="k">+ </span><span class="kt">.</span><span class="nf">↵</span> <span class="mi">1001</span>  <span class="nf">ok</span>
</span></span></code></pre></div><p>定义变量使用词 <code>VARIABLE</code>，给变量赋值使用词 <code>!</code>，取变量的值使用词 <code>@</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">VARIABLE</span> <span class="nc">name</span>	<span class="c1">( -- )</span>	<span class="c1">\ 定义一个名为 name 的变量。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>						<span class="c1">\ 系统分配 1 个单元的空间用于存储变量的值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>						<span class="c1">\ Forth 系统也许会将变量的初始值置为 0。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>						<span class="c1">\ 执行 name 时，会将存储变量值的单元的地址压入栈。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">!	</span><span class="c1">( n a-addr -- )</span>		<span class="c1">\ 将 n 存储到地址 a-addr。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">@	</span><span class="c1">( a-addr -- n )</span>		<span class="c1">\ 取出地址 a-addr 中存储的值。
</span></span></span></code></pre></div><p>下列词有时也会使用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="nf">+!</span>	<span class="c1">( n a-addr -- )</span>		<span class="c1">\ 将地址 a-addr 中存储的值加 n。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">?</span>	<span class="c1">( a-addr -- )</span>		<span class="c1">\ 取出地址 a-addr 中存储的值，并将其打印出来。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>						<span class="c1">\ 其定义相当于 : ?  @ . ;
</span></span></span></code></pre></div><p>例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">variable</span> <span class="nc">a↵</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">1000</span> <span class="nf">a</span> <span class="nf">!↵</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="nf">a</span> <span class="nf">?↵</span> <span class="mi">1000</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="nf">a</span> <span class="k">@ </span><span class="mi">1</span> <span class="k">+ </span><span class="kt">.</span><span class="nf">↵</span> <span class="mi">1001</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="nf">a</span> <span class="k">@ </span><span class="nf">a</span> <span class="k">@ + </span><span class="nf">a</span> <span class="nf">!↵</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="nf">a</span> <span class="nf">?↵</span> <span class="mi">2000</span>  <span class="nf">ok</span>
</span></span></code></pre></div><p>提示：分析这一程序片段时，可将 <code>a @</code> 看作一个整体（取变量 <code>a</code> 的值）；将 <code>a !</code> 看作一个整体（将栈顶元素存入变量 <code>a</code>)。</p>
<p>系统变量 <code>BASE</code> 存储解释器当前的数制。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">BASE	</span><span class="c1">( -- a-addr )</span>	<span class="c1">\ a-addr 中存储解释器当前的数制（2...36）。
</span></span></span></code></pre></div><p>显然，<code>HEX</code> 和 <code>DECIMAL</code> 可以这样定义：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">base </span><span class="nf">?↵</span> <span class="mi">10</span>  <span class="nf">ok</span>	<span class="c1">\ 注意定义时解释器当前的数制应为 10。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="c1">\ 也可用 #10 和 #16 指定定义中数字的数制。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">:</span> <span class="nc">hex</span>  <span class="mi">16</span> <span class="k">base ! </span><span class="nf">;↵</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">decimal</span>  <span class="mi">10</span> <span class="k">base ! </span><span class="nf">;↵</span>  <span class="nf">ok</span>
</span></span></code></pre></div><p>词 <code>UNUSED</code> 可用来获得剩余内存的数量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">unused </span><span class="kt">.</span><span class="nf">↵</span> <span class="mi">30928</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="kn">variable</span> <span class="nc">a↵</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="k">unused </span><span class="kt">.</span><span class="nf">↵</span> <span class="mi">30913</span>  <span class="nf">ok</span>	<span class="c1">\ 变量 a 的名称、代码、数据共占用 16 字节
</span></span></span></code></pre></div><h3 id="值的定义与使用">值的定义与使用</h3>
<p>操作变量与操作内存任意地址的方式完全相同，这提供了最大的灵活性。然而有时，只需要能够更改的单个的值而不需要其地址，亦即操作方式类似 <code>CONSTANT</code> 但可以更改。此时可使用 <code>VALUE</code> 来定义这种值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">VALUE</span> <span class="nc">name</span>	<span class="c1">( n -- )</span>	<span class="c1">\ 定义一个名为 name 的值，且将栈顶元素 n 存入其中。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>						<span class="c1">\ 执行 name 时，会将 n 压入栈。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">TO </span><span class="nf">name</span>		<span class="c1">( x -- )</span>	<span class="c1">\ 修改 name 的值：将栈顶元素 x 存入 name。
</span></span></span></code></pre></div><p>例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">1</span> <span class="kn">value</span> <span class="nc">va↵</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="nf">va</span> <span class="kt">.</span><span class="nf">↵</span> <span class="mi">1</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">100</span> <span class="k">to </span><span class="nf">va↵</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="nf">va</span> <span class="kt">.</span><span class="nf">↵</span> <span class="mi">100</span>  <span class="nf">ok</span>
</span></span></code></pre></div><h3 id="双精度数的常量变量与值">双精度数的常量、变量与值</h3>
<p>双精度数的常量、变量与值使用下面的词定义：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">2CONSTANT </span><span class="nf">name</span>	<span class="c1">( d -- )</span>	<span class="c1">\ 定义一个名为 name 的双精度常量。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="c1">\ 执行 x 时，会在栈中压入双精度数字 d。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">2VARIABLE </span><span class="nf">name</span>	<span class="c1">( -- )</span>		<span class="c1">\ 定义一个名为 name 的双精度变量。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">2VALUE </span><span class="nf">name</span>		<span class="c1">( d -- )</span>	<span class="c1">\ 定义一个名为 name 的双精度值，将双精度元素 d 存入其中。
</span></span></span></code></pre></div><p>使用下面的词操作双精度的变量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">2!	</span>	<span class="c1">( d a-addr -- )</span>		<span class="c1">\ 将双精度数 d 存储到地址 a-addr。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">2@	</span>	<span class="c1">( a-addr -- d )</span>		<span class="c1">\ 取出地址 a-addr 中存储的双精度数。
</span></span></span></code></pre></div><p>改变双精度值仍然使用词 <code>TO</code>。此时 <code>TO</code> 要求栈中有一个双精度数（所以前一节中 <code>TO</code> 的栈表示法中，执行前栈的内容用 <code>x</code> 表示）。</p>
<h2 id="内存分配数组与操作">内存分配（数组）与操作</h2>
<p>前面提到了 <code>VARIABLE</code> 会定义一个变量，并为其分配 1 个单元的空间。使用 <code>CREATE</code> 和 <code>ALLOT</code> 两个词，可以分配多于 1 个单元的空间：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">CREATE </span><span class="nf">name</span>	<span class="c1">( -- )</span>			<span class="c1">\ 定义一个名为 name 的词，但不分配空间。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="c1">\ 执行 name 的缺省行为是将其后面紧跟的数据区域的地址压入栈。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">ALLOT	</span>	<span class="c1">( n -- )</span>		<span class="c1">\ 分配 n 个寻址单位（字节）的存储空间（不改变其值）。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="c1">\ 大部分系统中的寻址单位为字节，My4TH Forth 也是如此。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="c1">\ 以下描述中混用“寻址单位”和“字节”，除非需要区分。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">CELLS	</span>	<span class="c1">( n1 -- n2 )</span>	<span class="c1">\ 返回 n1 个单元对应的字节数 n2。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">CELL</span>		<span class="c1">( -- n )</span>		<span class="c1">\ 返回 1 个单元对应的字节数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">CELL+	</span>	<span class="c1">( a-addr1 -- a-addr2 )</span>	<span class="c1">\ 返回 a-addr1 的下一个单元的地址 a-addr2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">ERASE	</span>	<span class="c1">( c-addr u -- )</span>	<span class="c1">\ 将 c-addr 开始的 u 个字节的值设置为 0。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">DUMP	</span>	<span class="c1">( addr u -- )</span>	<span class="c1">\ 打印内存中从 addr 开始 u 个字节的内容。
</span></span></span></code></pre></div><p>显然，<code>VARIABLE</code> 可以像这样定义（没有将初始值设置为 0）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">variable</span> <span class="c1">\ name ( -- )
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">create </span><span class="nf">cell</span> <span class="k">allot ;	</span><span class="c1">\ 执行 variable x 时，执行到 create 会在输入流中取得 x
</span></span></span></code></pre></div><p>使用这一方式，可以定义数组。如</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">create </span><span class="nf">weekrain</span>  <span class="mi">7</span> <span class="k">cells allot
</span></span></span></code></pre></div><p>可以定义一个 7 个单元的存储空间。正如其名称所示，<code>weekrain</code> 可用来存储一周的降水量。如果我们定义 7 个常数来代表一周七天——</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">0</span> <span class="k">cells </span><span class="kn">constant</span> <span class="nc">sun</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="k">cells </span><span class="kn">constant</span> <span class="nc">mon</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="k">cells </span><span class="kn">constant</span> <span class="nc">tue</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span> <span class="k">cells </span><span class="kn">constant</span> <span class="nc">wed</span>
</span></span><span class="line"><span class="cl"><span class="mi">4</span> <span class="k">cells </span><span class="kn">constant</span> <span class="nc">thu</span>
</span></span><span class="line"><span class="cl"><span class="mi">5</span> <span class="k">cells </span><span class="kn">constant</span> <span class="nc">fri</span>
</span></span><span class="line"><span class="cl"><span class="mi">6</span> <span class="k">cells </span><span class="kn">constant</span> <span class="nc">sat</span>
</span></span></code></pre></div><p>就可以方便地将存储空间当作数组使用。如</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="nf">weekrain</span> <span class="mi">7</span> <span class="k">cells erase	</span>	<span class="c1">\ 初始值清零
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">3</span> <span class="nf">weekrain</span> <span class="nf">tue</span> <span class="k">+ !	</span>		<span class="c1">\ 周二下了 3mm 雨
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">4</span> <span class="nf">weekrain</span> <span class="nf">tue</span> <span class="k">+ </span><span class="nf">+!</span>			<span class="c1">\ 周二又下了 4mm 雨
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nf">weekrain</span> <span class="nf">tue</span> <span class="k">+ </span><span class="nf">?↵</span> <span class="mi">7</span>  <span class="nf">ok</span>	<span class="c1">\ 周二的总降水量是 7mm
</span></span></span></code></pre></div><p>进一步地，如果想拥有更清晰的语义，可以进行如下定义：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">variable</span> <span class="nc">today</span>						<span class="c1">\ 记录当天在数组中的位移
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">:</span> <span class="nc">is-today</span> <span class="c1">( offset -- )</span> <span class="nf">today</span> <span class="k">! ;	</span><span class="c1">\ is-today 用于将当天的位移存入 today
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">:</span> <span class="nc">today-here</span> <span class="c1">( -- addr )</span>			<span class="c1">\ today-here 用于获得数组中存储当天的元素的地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="nf">weekrain</span> <span class="nf">today</span> <span class="k">@ + ;
</span></span></span><span class="line"><span class="cl"><span class="k"></span><span class="kn">:</span> <span class="nc">clear-rain</span> <span class="c1">( -- )</span> <span class="mi">0</span> <span class="nf">today-here</span> <span class="k">! ;	</span><span class="c1">\ clear-rain 用于清除当天降水记录
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">:</span> <span class="nc">fall</span> <span class="c1">( n -- )</span> <span class="nf">today-here</span> <span class="nf">+!</span> <span class="k">;	</span>	<span class="c1">\ fall 用来将一场雨的降水量添加到当天记录中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">:</span> <span class="nc">today-all</span> <span class="c1">( -- n )</span> <span class="nf">today-here</span> <span class="k">@ ;	</span><span class="c1">\ today-all 返回当天总降水量
</span></span></span></code></pre></div><p>有了这些定义，就可以用下面的方式来记录降水量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="nf">fri</span> <span class="nf">is-today</span>
</span></span><span class="line"><span class="cl"><span class="nf">clear-rain</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="nf">fall</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span> <span class="nf">fall</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="nf">fall</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="nf">fall</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">today-all</span> <span class="kt">.</span><span class="nf">↵</span> <span class="mi">8</span>  <span class="nf">ok</span>
</span></span></code></pre></div><p>如果想在定义存储空间的同时给其赋初值，可以使用词 <code>,</code><sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">,	</span><span class="c1">( n -- )</span>	<span class="c1">\ 分配 1 个单元的空间，并将这一空间初始化为 n。
</span></span></span></code></pre></div><p>设置初始值为 0 的 <code>variable</code> 可以这样定义：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">variable</span> <span class="c1">\ name ( -- )
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">create </span><span class="mi">0</span> <span class="k">, ;
</span></span></span></code></pre></div><p>如使用顺丰快递从北京向上海邮寄快件，1000g 以内邮费为 23 元，超过 1000g，每 500g 邮费增加 5 元，则 9500g 以内，500g 为单位的顺丰快递邮费表可定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">create </span><span class="nf">post-table</span>
</span></span><span class="line"><span class="cl">   <span class="mi">23</span> <span class="k">, </span><span class="mi">23</span> <span class="k">, </span><span class="mi">23</span> <span class="k">, </span><span class="mi">28</span> <span class="k">, </span><span class="mi">33</span> <span class="k">, </span>	<span class="c1">\ 0 ~ 2000g 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="mi">38</span> <span class="k">, </span><span class="mi">43</span> <span class="k">, </span><span class="mi">48</span> <span class="k">, </span><span class="mi">53</span> <span class="k">, </span><span class="mi">58</span> <span class="k">, </span> 	<span class="c1">\ 2500 ~ 4500g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="mi">63</span> <span class="k">, </span><span class="mi">68</span> <span class="k">, </span><span class="mi">73</span> <span class="k">, </span><span class="mi">78</span> <span class="k">, </span><span class="mi">83</span> <span class="k">,	</span>	<span class="c1">\ 5000 ~ 7000g
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="mi">88</span> <span class="k">, </span><span class="mi">93</span> <span class="k">, </span><span class="mi">98</span> <span class="k">, </span><span class="mi">103</span> <span class="k">, </span><span class="mi">108</span> <span class="k">,	</span><span class="c1">\ 7500 ~ 9500g
</span></span></span></code></pre></div><p>有了这一表格，计算以 g 为单位的顺丰快件的邮费的程序如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">grams</span> <span class="c1">( weight -- )</span>
</span></span><span class="line"><span class="cl">   <span class="k">1- </span><span class="mi">500</span> <span class="k">/ 1+ </span>		<span class="c1">\ 重量为 500g 的整数倍。 词 1- 将栈顶元素减一， 1+ 将栈顶元素加一。 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">cells	</span>		<span class="c1">\ 重量在表格中的位移。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="nf">post-table</span> <span class="k">+	</span>	<span class="c1">\ 求出重量的地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">@	</span>			<span class="c1">\ 取邮费的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">. </span><span class="s">.&#34;</span> <span class="s">yuan</span><span class="nf">&#34;</span> <span class="k">cr ;	</span><span class="c1">\ 打印邮费
</span></span></span></code></pre></div><p>这一程序的执行效果如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">100</span> <span class="nf">grams↵</span> <span class="mi">23</span> <span class="nf">yuan</span>
</span></span><span class="line"><span class="cl"> <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">1700</span> <span class="nf">grams↵</span> <span class="mi">33</span> <span class="nf">yuan</span>
</span></span><span class="line"><span class="cl"> <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">4800</span> <span class="nf">grams↵</span> <span class="mi">63</span> <span class="nf">yuan</span>
</span></span><span class="line"><span class="cl"> <span class="nf">ok</span>
</span></span></code></pre></div><h3 id="字符操作">字符操作</h3>
<p>8 位或 16 位机上一般的 Forth 系统中，一个单元的大小往往为 16 位（2 个字节），而一个字符的大小往往为 8 位（1 个字节）。以字符（1 个字节）为单位对内存进行操作的词如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">C!	</span>	<span class="c1">( c c-addr -- )</span>			<span class="c1">\ 将一个字符的值 c 存储到 c-addr。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">C@	</span>	<span class="c1">( c-addr -- c )</span>			<span class="c1">\ 从地址 c-addr 取出一个字符的值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">C,	</span>	<span class="c1">( c -- )</span>				<span class="c1">\ 分配一个字符的空间，并将这一空间初始化为 c。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">CHARS	</span><span class="c1">( n1 -- n2 )</span>			<span class="c1">\ 返回 n1 个字符对应的寻址单位数 n2。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">CHAR+	</span><span class="c1">( a-addr1 -- a-addr2 )</span>	<span class="c1">\ 返回 a-addr1 的下一个字符的地址 a-addr2。
</span></span></span></code></pre></div><p>显然，在 My4TH Forth 中，<code>CHARS</code> 不做任何操作，<code>CHAR+</code> 与 <code>1+</code> 等同。</p>
<h3 id="内存的分配堆指针与对齐">内存的分配，堆指针与对齐</h3>
<p><code>CREATE</code>、<code>ALLOT</code>、<code>,</code>、<code>C,</code>在一段<strong>连续的</strong>内存空间（一般称作<strong>堆</strong>（heap））<sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup>中连续地分配内存。因此，<code>CREATE</code> 后面才能用<code>ALLOT</code>、<code>,</code> 和 <code>C,</code> 继续分配内存。</p>
<p>堆中内存从低地址向高地址分配，堆指针指向空闲的第一个地址：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">HERE	</span><span class="c1">( -- addr )</span>	<span class="c1">\ 返回堆指针的地址。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">UNUSED	</span><span class="c1">( -- u )</span>	<span class="c1">\ 返回堆中可分配内存的字节数。
</span></span></span></code></pre></div><p>某些体系结构要求单元在内存中对齐（为机器字长的整倍数）。标准规定使用 <code>CREATE</code> 定义词时，内存地址会对齐。下列词用于人工对齐，往往在需要处理字符的程序中用到：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">ALIGN	</span><span class="c1">( -- )</span> <span class="c1">\ 如果堆指针未对齐，则保留足够多的空间使之对齐。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">ALIGNED </span><span class="c1">( addr -- a-addr )</span> <span class="c1">\ 返回大于等于 addr 的第一个对齐指针。
</span></span></span></code></pre></div><p><code>My4TH</code> 的体系结构不要求对齐。因此，My4TH Forth 中的 <code>ALIGN</code> 和 <code>ALIGNED</code> 两词不进行任何改变状态的操作。</p>
<p>设置初始值为 0 的 <code>variable</code> 也可以这样定义：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">variable</span> <span class="c1">\ name ( -- )
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">align here </span><span class="mi">0</span> <span class="k">, </span><span class="kn">constant</span> <span class="nc">;</span>
</span></span></code></pre></div><p>词 <code>BUFFER:</code> 可以用来分配一段缓冲区：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">BUFFER:</span> <span class="nc">name</span> <span class="c1">( u -- )</span>		<span class="c1">\ 建立一个名为 name 的缓冲区，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="c1">\ 并分配 u 个字节的空间给这个缓冲区。
</span></span></span></code></pre></div><p>用 <code>BUFFER:</code> 分配的缓冲区可以存在于其他空间中。当然如果用单一、连续的堆空间管理内存的话，<code>BUFFER:</code> 可以定义为</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">buffer:</span>  <span class="k">create allot ;
</span></span></span></code></pre></div><h2 id="定义词定义时行为与实例行为createdoes">定义词，定义时行为与实例行为，<code>CREATE</code>&hellip;<code>DOES&gt;</code></h2>
<p>从上面可以看出，有些词（如 <code>:</code>、<code>CREATE</code>、<code>VARIABLE</code> 等）用来定义其他的词。这些词称作<strong>定义词</strong> (defining word)。使用定义词定义其他词时执行的操作称作<strong>定义时行为</strong> (defining behavior)，执行被定义的词时执行的操作称作<strong>实例行为</strong> (instance behavior)。如词 <code>VARIABLE</code> 的定义时行为是分配 1 个单元的内存并将其清零，实例行为是将定义时分配的内存单元的地址压入栈。</p>
<p>使用下面的格式，可以定义一个定义词：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">name</span>  <span class="k">CREATE	</span><span class="c1">( 定义时行为 )</span>
</span></span><span class="line"><span class="cl">        <span class="k">DOES&gt;	</span><span class="c1">( 实例行为 )</span> <span class="k">;
</span></span></span></code></pre></div><p>执行实例行为前，<code>name</code> 对应的数据区域地址会压入栈内（这也是 没有 <code>DOES&gt;</code> 的 <code>CREATE</code> 的缺省行为）。</p>
<p>如 <code>CONSTANT</code> 可以这样定义：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">constant</span>
</span></span><span class="line"><span class="cl">   <span class="k">create ,	</span>	<span class="c1">\ 定义时行为：分配 1 个单元的内存，将栈顶元素存入其中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">DOES&gt; @ ;	</span><span class="c1">\ 实例行为：取出中存储的值
</span></span></span></code></pre></div><p><code>CREATE</code>&hellip;<code>DOES&gt;</code><sup id="fnref:7"><a href="#fn:7" class="footnote-ref" role="doc-noteref">7</a></sup> 是 Forth 中非常灵活的一项工具，可以用来定义复杂的数据结构。下面是一个字符型二维数组的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">array</span> <span class="c1">( #rows #cols -- )</span>
</span></span><span class="line"><span class="cl">   <span class="k">create dup , * allot	</span>	<span class="c1">\ 定义时行为：将 #cols 存入内存，然后分配 #rows * #cols 的空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">does&gt; </span><span class="c1">( member: row col -- c-addr )</span>	
</span></span><span class="line"><span class="cl">   <span class="k">rot over @ * + + cell+ ;
</span></span></span></code></pre></div><p><code>array</code> 的实例行为如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl">			<span class="c1">( row col addr )</span>
</span></span><span class="line"><span class="cl">	<span class="k">rot	</span>	<span class="c1">( col addr row )</span>
</span></span><span class="line"><span class="cl">	<span class="k">over	</span><span class="c1">( col addr row addr )</span>
</span></span><span class="line"><span class="cl">	<span class="k">@	</span>	<span class="c1">( col addr row #cols )</span>
</span></span><span class="line"><span class="cl">	<span class="k">*	</span>	<span class="c1">( col addr row*#cols )</span>
</span></span><span class="line"><span class="cl">	<span class="k">+	</span>	<span class="c1">( col addr+row*#cols )</span>
</span></span><span class="line"><span class="cl">	<span class="k">+	</span>	<span class="c1">( addr+row*#cols+col )</span>
</span></span><span class="line"><span class="cl">	<span class="k">cell+	</span><span class="c1">( addr+row*#cols+col+cell )</span>	<span class="c1">\ 加的 cell 为 #cols 的存储单元
</span></span></span></code></pre></div><p>这样，定义一个 4*4 字节的数组 <code>board</code> 可以用<sup id="fnref:8"><a href="#fn:8" class="footnote-ref" role="doc-noteref">8</a></sup></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">4</span> <span class="mi">4</span> <span class="nf">array</span>  <span class="nf">board</span>
</span></span></code></pre></div><p>操作数组的某个元素的方式为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">2</span> <span class="mi">1</span> <span class="nf">board</span> <span class="k">c@
</span></span></span></code></pre></div><h2 id="算术关系及位运算">算术、关系及位运算</h2>
<h3 id="常用的算术运算词">常用的算术运算词</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="nf">(单精度)</span>
</span></span><span class="line"><span class="cl"><span class="k">+	</span>	<span class="c1">( n1 n2 -- n3 )</span>		<span class="c1">\ n3=n1+n2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">-	</span>	<span class="c1">( n1 n2 -- n3 )</span>		<span class="c1">\ n3=n1-n2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">*	</span>	<span class="c1">( n1 n2 -- n3 )</span>		<span class="c1">\ n3=n1*n2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">/	</span>	<span class="c1">( n1 n2 -- n3 )</span>		<span class="c1">\ n3=n1/n2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">*/</span>		<span class="c1">( n1 n2 n3 -- n4 )</span>	<span class="c1">\ n4=n1*n2/n3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">MOD	</span>	<span class="c1">( n1 n2 -- n3 )</span>		<span class="c1">\ n3=n1 mod n2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">/MOD	</span><span class="c1">( n1 n2 -- n3 n4 )</span>	<span class="c1">\ n3=n1 mod n2, n4=n1/n2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">*/MOD	</span><span class="c1">( n1 n2 n3 -- n4 n5)</span>	<span class="c1">\ n4=(n1*n2) mod n3, n5=n1*n2/n3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">NEGATE	</span><span class="c1">( n1 -- n2 )</span>		<span class="c1">\ n2=-n1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">ABS	</span>	<span class="c1">( n1 -- n2 )</span>		<span class="c1">\ n2=|n1|
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">1+	</span>	<span class="c1">( n1 -- n2 )</span>		<span class="c1">\ n2=n1+1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">1-	</span>	<span class="c1">( n1 -- n2 )</span>		<span class="c1">\ n2=n1-1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">2*	</span>	<span class="c1">( n1 -- n2 )</span>		<span class="c1">\ n2=n1*2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">2/	</span>	<span class="c1">( n1 -- n2 )</span>		<span class="c1">\ n2=n1/2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">MAX	</span>	<span class="c1">( n1 n2 -- n3 )</span>		<span class="c1">\ n3=max(n1, n2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">MIN	</span>	<span class="c1">( n1 n2 -- n3 )</span>		<span class="c1">\ n3=min(n1, n2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nf">(混合及双精度)</span>
</span></span><span class="line"><span class="cl"><span class="k">S&gt;D	</span>	<span class="c1">( n -- d )</span>			<span class="c1">\ d=n
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">D&gt;S	</span>	<span class="c1">( d -- n )</span>			<span class="c1">\ n=d，d 必须在 n 能表示的范围内
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">M+	</span>	<span class="c1">( d1 n -- d2 )</span>		<span class="c1">\ d2=d1+n
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">D+	</span>	<span class="c1">( d1 d2 -- d3 )</span>		<span class="c1">\ d3=d1+d2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">D-	</span>	<span class="c1">( d1 d2 -- d3 )</span>		<span class="c1">\ d3=d1-d2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">M*	</span>	<span class="c1">( n1 n2 -- d )</span>		<span class="c1">\ d=n1*n2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">UM*	</span>	<span class="c1">( u1 u2 -- ud )</span>		<span class="c1">\ ud=u1*u2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">M*/	</span>	<span class="c1">( d1 n1 +n2 -- d2 )</span>	<span class="c1">\ d2=d1*n1/(+n2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">FM/MOD	</span><span class="c1">( d1 n1 -- n2 n3 )</span>	<span class="c1">\ n2=d1 mod n1, n3=d1/n1	（下取整除法(floored division)）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SM/REM	</span><span class="c1">( d1 n1 -- n2 n3 )</span>	<span class="c1">\ n2=d1 mod n1, n3=d1/n1	（对称除法(symmetric division)） 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">UM/MOD	</span><span class="c1">( ud u1 -- u2 u3 )</span>	<span class="c1">\ u2=ud mod u1, u3=ud/u1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">DNEGATE	</span><span class="c1">( d1 -- d2 )</span>		<span class="c1">\ d2=-d1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">DABS	</span><span class="c1">( d1 -- d2 )</span>		<span class="c1">\ d2=|d1|
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">DMAX	</span><span class="c1">( d1 d2 -- d3 )</span>		<span class="c1">\ d3=max(d1, d2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">DMIN	</span><span class="c1">( d1 d2 -- d3 )</span>		<span class="c1">\ d3=min(d1, d2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">D2*	</span>	<span class="c1">( d1 -- d2 )</span>		<span class="c1">\ d2=d1*2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">D2/	</span>	<span class="c1">( d1 -- d2 )</span>		<span class="c1">\ d2=d1/2
</span></span></span></code></pre></div><p><code>*/</code> 和 <code>/MOD</code> 的中间结果是双精度整数；<code>M*/</code> 的中间结果占据 3 个单元<sup id="fnref:9"><a href="#fn:9" class="footnote-ref" role="doc-noteref">9</a></sup>。</p>
<p>下取整除法和对称除法在除数和被除数之一为负数且有余数时有区别，例子见下表：</p>
<table>
  <thead>
      <tr>
          <th>被除数 <em>a</em></th>
          <th>除数 <em>b</em></th>
          <th>余数 <em>r</em>（下取整除法）</th>
          <th>商 <em>q</em>（下取整除法）</th>
          <th>余数 <em>r</em>（对称除法）</th>
          <th>商 <em>q</em>（对称除法）</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>10</td>
          <td>7</td>
          <td>3</td>
          <td>1</td>
          <td>3</td>
          <td>1</td>
      </tr>
      <tr>
          <td>-10</td>
          <td>7</td>
          <td>4</td>
          <td>-2</td>
          <td>-3</td>
          <td>-1</td>
      </tr>
      <tr>
          <td>10</td>
          <td>-7</td>
          <td>-4</td>
          <td>-2</td>
          <td>3</td>
          <td>-1</td>
      </tr>
      <tr>
          <td>-10</td>
          <td>-7</td>
          <td>-3</td>
          <td>1</td>
          <td>-3</td>
          <td>1</td>
      </tr>
  </tbody>
</table>
<p>两种除法都满足 <em>b</em> × <em>q</em> + <em>r</em> = <em>a</em>。进一步的解释参见 <a href="https://forth-standard.org/standard/usage#subsubsection.3.2.2.1">Forth 2012 标准 3.2.2.1 节</a>。</p>
<h3 id="常用的位运算词">常用的位运算词</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">INVERT	</span><span class="c1">( n1 -- n2 )</span>		<span class="c1">\ 对 n1 按位取反。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">AND	</span>	<span class="c1">( n1 n2 -- n3 )</span>		<span class="c1">\ 返回 n1 和 n2 按位与的结果。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">OR	</span>	<span class="c1">( n1 n2 -- n3 )</span>		<span class="c1">\ 返回 n1 和 n2 按位或的结果。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">XOR	</span>	<span class="c1">( n1 n2 -- n3 )</span>		<span class="c1">\ 返回 n1 和 n2 按位异或的结果。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">LSHIFT	</span><span class="c1">( n1 u -- n2 )</span>		<span class="c1">\ 返回 n1 左移 u 位的结果。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">RSHIFT	</span><span class="c1">( n1 u -- n2 )</span>		<span class="c1">\ 返回 n1 右移 u 位的结果。
</span></span></span></code></pre></div><h3 id="常用的关系运算词">常用的关系运算词</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">&lt;	</span>	<span class="c1">( n1 n2 -- f )</span>	<span class="c1">\ 若 n1&lt;n2, 返回真；否则返回假。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">&lt;=</span>		<span class="c1">( n1 n2 -- f )</span>	<span class="c1">\ 若 n1&lt;=n2, 返回真；否则返回假。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">&lt;&gt;</span>		<span class="c1">( n1 n2 -- f )</span>	<span class="c1">\ 若 n1不等于n2, 返回真；否则返回假。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">=</span>		<span class="c1">( n1 n2 -- f )</span>	<span class="c1">\ 若 n1=n2，返回真；否则返回假。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">&gt;	</span>	<span class="c1">( n1 n2 -- f )</span>	<span class="c1">\ 若 n1&gt;n2, 返回真；否则返回假。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">&gt;=</span>		<span class="c1">( n1 n2 -- f )</span>	<span class="c1">\ 若 n1&gt;=n2, 返回真；否则返回假。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">0&lt;	</span>	<span class="c1">( n -- f )</span>		<span class="c1">\ 若 n&lt;0, 返回真；否则返回假。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">0&lt;&gt;	</span>	<span class="c1">( n -- f )</span>		<span class="c1">\ 若 n不等于0, 返回真；否则返回假。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">0=	</span>	<span class="c1">( n -- f )</span>		<span class="c1">\ 若 n=0, 返回真；否则返回假。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">0&gt;	</span>	<span class="c1">( n -- f )</span>		<span class="c1">\ 若 n&gt;0, 返回真；否则返回假。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">U&lt;	</span>	<span class="c1">( u1 u2 -- f )</span>	<span class="c1">\ 若 u1&lt;u2, 返回真；否则返回假。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">U&gt;	</span>	<span class="c1">( u1 u2 -- f )</span>	<span class="c1">\ 若 u1&gt;u2, 返回真；否则返回假。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">WITHIN	</span><span class="c1">( n1 n2 n3 -- f)</span>	<span class="c1">\ 若 n1≥n2且n2&lt;n3，返回真，否则返回假。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="c1">\ n1 n2 n3 必须同为有符号数或同为无符号数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">TRUE	</span><span class="c1">( -- f )</span>		<span class="c1">\ 返回真。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">FALSE	</span><span class="c1">( -- f )</span>		<span class="c1">\ 返回假。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">D0&lt; </span>	<span class="c1">( d -- f )</span> 		<span class="c1">\ 若 d&lt;0, 返回真；否则返回假。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">D0=	</span>	<span class="c1">( d -- f )</span> 		<span class="c1">\ 若 d=0, 返回真；否则返回假。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">D&lt;	</span>	<span class="c1">( d1 d2 -- f )</span>	<span class="c1">\ 若 d1&lt;d2, 返回真；否则返回假。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">D=	</span>	<span class="c1">( d1 d2 -- f )</span>	<span class="c1">\ 若 d1=d2, 返回真；否则返回假。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">DU&lt;	</span>	<span class="c1">( ud1 ud2 -- f )</span>	<span class="c1">\ 若 ud1&lt;ud2, 返回真；否则返回假。
</span></span></span></code></pre></div><p>标志的取值为<strong>真</strong>或<strong>假</strong>。一般地，假用值为 0 的单元表示，真用值不为 0 的单元表示。因此，<code>0=</code> 执行的运算也就是逻辑非。</p>
<p>如果真用所有位均为 1（也就是有符号的值为 -1）的单元表示，假用所有位均为 0（也就是值为 0）的单元表示，则称这一标志为<strong>合式</strong>的（well-formed），否则称这一标志为<strong>不合式</strong>的（ill-formed）。常用的关系运算词均返回合式标志。</p>
<p>显然，合式标志可用位运算词 <code>AND</code>、<code>OR</code> 和 <code>XOR</code> 进行运算。某些词返回不合式标志，这类标志要参与位运算，需要使用 <code>0&lt;&gt;</code> 或 <code>0=</code> 将其转换为合式标志。</p>
<h2 id="分支与循环">分支与循环</h2>
<h3 id="条件分支-ifelsethen">条件分支 (<code>IF</code>&hellip;<code>ELSE</code>&hellip;<code>THEN</code>)</h3>
<p>条件分支使用的词如下<sup id="fnref:10"><a href="#fn:10" class="footnote-ref" role="doc-noteref">10</a></sup>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">IF	</span>	<span class="c1">( rt: f -- )</span>	<span class="c1">\ 如果 f 为真，则执行 IF 后面紧跟着的指令
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>						<span class="c1">\ 直到遇到 ELSE 或 THEN 为止。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	                    <span class="c1">\ 此时如果有 ELSE，则跳过 ELSE 后面的指令直到 THEN。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	                    <span class="c1">\ 如果 f 为假，执行 ELSE 或 THEN 后面的指令。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">ELSE	</span><span class="c1">( rt: -- )</span>		<span class="c1">\ 用在 IF...ELSE...THEN 结构中，后跟 f 为假时执行的语句。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">THEN	</span><span class="c1">( rt: -- )</span>		<span class="c1">\ 用于结束一个 IF...ELSE...THEN 结构。
</span></span></span></code></pre></div><p>如<sup id="fnref:11"><a href="#fn:11" class="footnote-ref" role="doc-noteref">11</a></sup>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">cond</span> <span class="c1">( f -- )</span>
</span></span><span class="line"><span class="cl">   <span class="k">if </span>
</span></span><span class="line"><span class="cl">      <span class="s">.&#34;</span> <span class="s">True.</span><span class="nf">&#34;</span> 
</span></span><span class="line"><span class="cl">   <span class="k">else
</span></span></span><span class="line"><span class="cl"><span class="k"></span>      <span class="s">.&#34;</span> <span class="s">False.</span><span class="nf">&#34;</span>
</span></span><span class="line"><span class="cl">   <span class="k">then </span> <span class="k">cr ;
</span></span></span></code></pre></div><p>可以判断栈顶的标志是不是 0，并打印出 True 或 False 。</p>
<p>前面提到的关系运算词，在条件分支中有广泛的应用。上面程序的执行效果如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">2</span> <span class="k">&gt; </span><span class="nf">cond↵</span> <span class="nf">False.</span>	<span class="c1">\ 1 大于 2 么？否。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="mi">1</span> <span class="k">&gt; </span><span class="nf">cond↵</span> <span class="nf">True.</span>	<span class="c1">\ 2 大于 1 么？是。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="nf">ok</span>
</span></span></code></pre></div><p>需要注意的是，<code>IF</code> 会用掉栈顶的元素，关系运算词会用掉栈顶的一个或两个元素。故在条件分支嵌套时，<code>DUP</code> 大有用武之地。如下列检查收缩压是否正常的程序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">?normal</span> <span class="c1">( n -- )</span>
</span></span><span class="line"><span class="cl">   <span class="k">dup </span><span class="mi">70</span> <span class="k">&lt; if
</span></span></span><span class="line"><span class="cl"><span class="k"></span>      <span class="s">.&#34;</span> <span class="s">Too low.</span><span class="nf">&#34;</span> 
</span></span><span class="line"><span class="cl">   <span class="k">else
</span></span></span><span class="line"><span class="cl"><span class="k"></span>      <span class="k">dup </span><span class="mi">90</span> <span class="k">&lt; if
</span></span></span><span class="line"><span class="cl"><span class="k"></span>         <span class="s">.&#34;</span> <span class="s">Low.</span><span class="nf">&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="k">else
</span></span></span><span class="line"><span class="cl"><span class="k"></span>         <span class="k">dup </span><span class="mi">130</span> <span class="k">&lt; if
</span></span></span><span class="line"><span class="cl"><span class="k"></span>            <span class="s">.&#34;</span> <span class="s">Normal.</span><span class="nf">&#34;</span>
</span></span><span class="line"><span class="cl">         <span class="k">else
</span></span></span><span class="line"><span class="cl"><span class="k"></span>            <span class="k">dup </span><span class="mi">150</span> <span class="k">&lt; if
</span></span></span><span class="line"><span class="cl"><span class="k"></span>               <span class="s">.&#34;</span> <span class="s">Higher than normal.</span><span class="nf">&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="k">else
</span></span></span><span class="line"><span class="cl"><span class="k"></span>               <span class="s">.&#34;</span> <span class="s">Should see doctor.</span><span class="nf">&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="k">then
</span></span></span><span class="line"><span class="cl"><span class="k"></span>         <span class="k">then
</span></span></span><span class="line"><span class="cl"><span class="k"></span>      <span class="k">then
</span></span></span><span class="line"><span class="cl"><span class="k"></span>   <span class="k">then </span> <span class="k">drop cr ;
</span></span></span></code></pre></div><p>上述程序的执行效果如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">95</span> <span class="nf">?normal↵</span> <span class="nf">Normal.</span>
</span></span><span class="line"><span class="cl"> <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">70</span> <span class="nf">?normal↵</span> <span class="nf">Low.</span>
</span></span><span class="line"><span class="cl"> <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">145</span> <span class="nf">?normal↵</span> <span class="nf">Higher</span> <span class="nf">than</span> <span class="nf">normal.</span>
</span></span><span class="line"><span class="cl"> <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">160</span> <span class="nf">?normal↵</span> <span class="nf">Should</span> <span class="k">see </span><span class="nf">doctor.</span>
</span></span><span class="line"><span class="cl"> <span class="nf">ok</span>
</span></span></code></pre></div><p>要注意的是，一开始 <code>DUP</code> 的值，最后不用的时候，应该 <code>DROP</code> 掉。否则栈内元素会越来越多，导致溢出。调试程序时，应多用 <code>DEPTH .</code> 和 <code>.S</code> 来检查。</p>
<p>在这种多层判断的场合下，用 <code>EXIT</code> 比用 <code>ELSE</code> 能让程序更加清晰：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">(?normal)</span> <span class="c1">( n -- n )</span>
</span></span><span class="line"><span class="cl">   <span class="k">dup </span><span class="mi">70</span> <span class="k">&lt; if </span> <span class="s">.&#34;</span> <span class="s">Too low.</span><span class="nf">&#34;</span> <span class="k">exit then
</span></span></span><span class="line"><span class="cl"><span class="k"></span>   <span class="k">dup </span><span class="mi">90</span> <span class="k">&lt; if </span> <span class="s">.&#34;</span> <span class="s">Low.</span><span class="nf">&#34;</span> <span class="k">exit then
</span></span></span><span class="line"><span class="cl"><span class="k"></span>   <span class="k">dup </span><span class="mi">130</span> <span class="k">&lt; if </span><span class="s">.&#34;</span> <span class="s">Normal.</span><span class="nf">&#34;</span> <span class="k">exit then
</span></span></span><span class="line"><span class="cl"><span class="k"></span>   <span class="k">dup </span><span class="mi">150</span> <span class="k">&lt; if </span><span class="s">.&#34;</span> <span class="s">Higher than normal.</span><span class="nf">&#34;</span> <span class="k">exit then
</span></span></span><span class="line"><span class="cl"><span class="k"></span>                <span class="s">.&#34;</span> <span class="s">Should see doctor.</span><span class="nf">&#34;</span> <span class="k">;
</span></span></span><span class="line"><span class="cl"><span class="k"></span><span class="kn">:</span> <span class="nc">?normal</span> <span class="c1">( n -- )</span> <span class="nf">(?normal)</span> <span class="k">drop cr ;
</span></span></span></code></pre></div><p>有时会遇到栈顶元素非零时程序要做某项工作，否则不做工作的情形。如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">/check</span>
</span></span><span class="line"><span class="cl">   <span class="k">dup if
</span></span></span><span class="line"><span class="cl"><span class="k"></span>      <span class="k">/
</span></span></span><span class="line"><span class="cl"><span class="k"></span>   <span class="k">else
</span></span></span><span class="line"><span class="cl"><span class="k"></span>      <span class="k">drop </span>
</span></span><span class="line"><span class="cl">   <span class="k">then ;
</span></span></span></code></pre></div><p>由于所有的非零数字都被认为是真，所以可以直接用栈顶元素当作 <code>IF</code> 的标志。需要注意的是，如果要使用栈顶元素，那么首先要 <code>DUP</code>。Forth 提供词 <code>?DUP</code><sup id="fnref:12"><a href="#fn:12" class="footnote-ref" role="doc-noteref">12</a></sup> 来简化这一问题：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">?DUP	</span><span class="c1">( n -- n n | 0 )</span>		<span class="c1">\ 如果栈顶元素非 0, 则 DUP； 否则保持栈顶的 0 不变。
</span></span></span></code></pre></div><p>因此，上面的程序可写作</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">/check</span>
</span></span><span class="line"><span class="cl">   <span class="k">?dup if
</span></span></span><span class="line"><span class="cl"><span class="k"></span>      <span class="k">/
</span></span></span><span class="line"><span class="cl"><span class="k"></span>   <span class="k">then ;
</span></span></span></code></pre></div><h3 id="多重分支caseofendofendcase">多重分支（<code>CASE</code>&hellip;<code>OF</code>&hellip;<code>ENDOF</code>&hellip;<code>ENDCASE</code>）</h3>
<p>多重分支使用的词如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">CASE	</span><span class="c1">( rt: -- )</span>			<span class="c1">\ 用于开始一个 CASE...OF...ENDOF...ENDCASE 结构。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">ENDCASE	</span><span class="c1">( rt: n -- )</span>		<span class="c1">\ 抛弃栈顶元素 n （一般为多重分支的选择子）并继续执行。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="c1">\ 用于结束一个 CASE...OF...ENDOF...ENDCASE 结构。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">ENDOF	</span><span class="c1">( rt: -- )</span>			<span class="c1">\ 跳转到 ENDCASE 后面的指令。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">OF	</span>	<span class="c1">( rt: n1 n2 -- n1 )</span>	<span class="c1">\ 如果 n2&lt;&gt;n1，则从栈中抛弃 n2，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="c1">\ 跳转到对应的 ENDOF 之后继续执行；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="c1">\ 如果 n2=n1，则从栈中抛弃 n1 和 n2，执行 OF 后面的指令。
</span></span></span></code></pre></div><p>多重分支的格式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="nf">n</span> <span class="k">CASE
</span></span></span><span class="line"><span class="cl"><span class="k"></span>   <span class="c1">( n )</span> <span class="nf">some-forth-code</span> <span class="c1">( n )</span>
</span></span><span class="line"><span class="cl">   <span class="nf">n1</span> <span class="k">OF </span><span class="nf">forth-code1</span> <span class="k">ENDOF
</span></span></span><span class="line"><span class="cl"><span class="k"></span>   <span class="nf">n2</span> <span class="k">OF </span><span class="nf">forth-code2</span> <span class="k">ENDOF
</span></span></span><span class="line"><span class="cl"><span class="k"></span>   <span class="kt">...</span>
</span></span><span class="line"><span class="cl">   <span class="c1">( n )</span> <span class="nf">default-forth-code</span> <span class="c1">( n )</span>
</span></span><span class="line"><span class="cl"><span class="k">ENDCASE </span><span class="c1">( )</span>
</span></span></code></pre></div><p>注意 <code>some-forth-code</code> 和 <code>default-forth-code</code> 均可为空。但是如果它们不为空，则它们前后需要保留栈中的元素 <code>n</code>。</p>
<p>以下是多重分支的一个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">test</span> <span class="c1">( n -- )</span> <span class="k">case </span><span class="s">.&#34;</span> <span class="s">Value is </span><span class="nf">&#34;</span>
</span></span><span class="line"><span class="cl">   <span class="mi">1</span> <span class="k">of </span><span class="s">.&#34;</span> <span class="s">One</span><span class="nf">&#34;</span> <span class="k">endof
</span></span></span><span class="line"><span class="cl"><span class="k"></span>   <span class="mi">2</span> <span class="k">of </span><span class="s">.&#34;</span> <span class="s">Two</span><span class="nf">&#34;</span> <span class="k">endof
</span></span></span><span class="line"><span class="cl"><span class="k"></span>   <span class="mi">3</span> <span class="k">of </span><span class="s">.&#34;</span> <span class="s">Three</span><span class="nf">&#34;</span> <span class="k">endof
</span></span></span><span class="line"><span class="cl"><span class="k"></span>   <span class="k">dup .
</span></span></span><span class="line"><span class="cl"><span class="k">endcase ;
</span></span></span></code></pre></div><p>运行效果如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">1</span> <span class="nf">test↵</span> <span class="kn">Value</span> <span class="nc">is</span> <span class="nf">One</span> <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="nf">test↵</span> <span class="kn">Value</span> <span class="nc">is</span> <span class="nf">Two</span> <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span> <span class="nf">test↵</span> <span class="kn">Value</span> <span class="nc">is</span> <span class="nf">Three</span> <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">4</span> <span class="nf">test↵</span> <span class="kn">Value</span> <span class="nc">is</span> <span class="mi">4</span>  <span class="nf">ok</span>
</span></span></code></pre></div><h3 id="有限循环-doloop-与返回栈">有限循环 (<code>DO</code>&hellip;<code>LOOP</code>) 与返回栈</h3>
<p>最基本的有限循环使用 <code>DO</code> 和 <code>LOOP</code> 及几个类似的词：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">DO	</span>	<span class="c1">( rt: lim n -- )</span>	<span class="c1">\ 设循环变量初值为 n，然后执行执行下面的程序，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="c1">\ 直到遇到对应的 LOOP 或 +LOOP。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        	<span class="c1">\ 此时判断循环变量的值，若没有越过 lim-1 与 lim 的边界，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        	<span class="c1">\ 则返回 DO 后面第一个词继续执行；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        	<span class="c1">\ 若越过了 lim-1 与 lim 的边界（循环变量&gt;=lim），
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        	<span class="c1">\ 则从 LOOP 或 +LOOP 后第一个词继续执行。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        	<span class="c1">\ 注意 DO 至少执行后面的循环体一次。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        	<span class="c1">\ 如果要在循环体执行前判断 n 和 lim 的关系，需要使用 ?DO。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">?DO	</span> 	<span class="c1">( rt: lim n -- )</span>	<span class="c1">\ 先判断 n 和 lim 的关系。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="c1">\ 若 lim=n，则直接跳到对应的 LOOP 或 +LOOP 后面；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="c1">\ 否则与 DO 相同。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">LOOP	</span><span class="c1">( rt: -- )</span>			<span class="c1">\ 循环变量加 1，同时用于标记循环的结束位置。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">+LOOP	</span><span class="c1">( rt: m -- )</span>		<span class="c1">\ 循环变量加 m，同时用于标记循环的结束位置。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">I	</span>	<span class="c1">( rt: -- i )</span>		<span class="c1">\ 返回本层循环变量的值。 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">J	</span>	<span class="c1">( rt: -- j )</span>		<span class="c1">\ 返回上一层循环变量的值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">K</span>		<span class="c1">( rt: -- k )</span>		<span class="c1">\ 返回上两层循环变量的值。 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">L</span>		<span class="c1">( rt: -- l )</span>		<span class="c1">\ 返回上三层循环变量的值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">LEAVE	</span><span class="c1">( rt: -- )</span>			<span class="c1">\ 退出当前层循环。 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">UNLOOP </span> <span class="c1">( rt: -- )</span>			<span class="c1">\ 抛弃当前层循环的状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="c1">\ （用于在循环中 EXIT 退出当前词的程序之前）。
</span></span></span></code></pre></div><p>如下列程序可计算 1&hellip;100 的和：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">sum</span> <span class="c1">( -- )</span>
</span></span><span class="line"><span class="cl">   <span class="mi">0</span> 
</span></span><span class="line"><span class="cl">   <span class="mi">101</span> <span class="mi">1</span> <span class="k">do
</span></span></span><span class="line"><span class="cl"><span class="k"></span>      <span class="k">i +
</span></span></span><span class="line"><span class="cl"><span class="k"></span>   <span class="k">loop
</span></span></span><span class="line"><span class="cl"><span class="k"></span>   <span class="k">. cr ;
</span></span></span></code></pre></div><p>运行结果如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="nf">sum↵</span> <span class="mi">5050</span>
</span></span><span class="line"><span class="cl"> <span class="nf">ok</span>
</span></span></code></pre></div><p>下列程序可打印三角形：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">triangle</span> <span class="c1">( lines -- )</span>
</span></span><span class="line"><span class="cl">   <span class="k">dup </span><span class="mi">1</span> <span class="k">&lt; if
</span></span></span><span class="line"><span class="cl"><span class="k"></span>      <span class="s">.&#34;</span> <span class="s">Lines cannot be less than 1.</span><span class="nf">&#34;</span> <span class="k">cr
</span></span></span><span class="line"><span class="cl"><span class="k"></span>      <span class="k">drop exit </span>
</span></span><span class="line"><span class="cl">   <span class="k">then
</span></span></span><span class="line"><span class="cl"><span class="k"></span>   <span class="k">cr </span><span class="mi">1</span> <span class="k">+
</span></span></span><span class="line"><span class="cl"><span class="k"></span>   <span class="mi">1</span> <span class="k">do
</span></span></span><span class="line"><span class="cl"><span class="k"></span>      <span class="k">i . </span><span class="mi">9</span> <span class="k">emit </span><span class="c1">\ 词 EMIT 的作用是打印栈顶元素对应 ASCII 码的字符。TAB 的 ASCII 码为 9.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">i </span><span class="mi">0</span> <span class="k">do
</span></span></span><span class="line"><span class="cl"><span class="k"></span>         <span class="s">.&#34;</span> <span class="s">*</span><span class="nf">&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="k">loop
</span></span></span><span class="line"><span class="cl"><span class="k"></span>      <span class="k">cr
</span></span></span><span class="line"><span class="cl"><span class="k"></span>   <span class="k">loop ;
</span></span></span></code></pre></div><p>运行结果如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">3</span> <span class="nf">triangle↵</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span>       <span class="k">*
</span></span></span><span class="line"><span class="cl"><span class="k"></span><span class="mi">2</span>       <span class="nf">**</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span>       <span class="nf">***</span>
</span></span><span class="line"><span class="cl"> <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">0</span> <span class="nf">triangle↵</span> <span class="nf">Lines</span> <span class="nf">cannot</span> <span class="nf">be</span> <span class="nf">less</span> <span class="nf">than</span> <span class="mi">1</span><span class="k">.
</span></span></span><span class="line"><span class="cl"><span class="k"></span> <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">5</span> <span class="nf">triangle↵</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span>       <span class="k">*
</span></span></span><span class="line"><span class="cl"><span class="k"></span><span class="mi">2</span>       <span class="nf">**</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span>       <span class="nf">***</span>
</span></span><span class="line"><span class="cl"><span class="mi">4</span>       <span class="nf">****</span>
</span></span><span class="line"><span class="cl"><span class="mi">5</span>       <span class="nf">*****</span>
</span></span><span class="line"><span class="cl"> <span class="nf">ok</span>
</span></span></code></pre></div><p>在 Forth 中，循环变量和循环界限都存储在返回栈中。<code>I</code>、<code>J</code>、<code>K</code>、<code>L</code> 的作用就是从返回栈中取得本层、上一层、大上一层、再大上一层的循环变量的值。</p>
<p>下列词可以直接对返回栈进行操作<sup id="fnref:13"><a href="#fn:13" class="footnote-ref" role="doc-noteref">13</a></sup>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">&gt;R	</span>	<span class="c1">( n -- )</span> <span class="c1">( R: -- n )</span>	<span class="c1">\ 将参数栈栈顶元素弹出，并压入返回栈。 “去返回栈”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">R&gt;	</span>	<span class="c1">( -- n )</span> <span class="c1">( R: n -- )</span>	<span class="c1">\ 将返回栈栈顶元素弹出，并压入参数栈。“从返回栈来”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">R@	</span>	<span class="c1">( -- n )</span> <span class="c1">( R: n -- n )</span>	<span class="c1">\ 将返回栈栈顶元素复制到参数栈。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">2&gt;R	</span>	<span class="c1">( d -- )</span> <span class="c1">( R: -- d )</span>	<span class="c1">\ 将参数栈栈顶的双精度整数（两个元素）弹出，并压入返回栈。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">2R&gt; </span>	<span class="c1">( -- d )</span> <span class="c1">( R: d -- )</span>	<span class="c1">\ 将返回栈栈顶的双精度整数（两个元素）弹出，并压入参数栈。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">2R@	</span>	<span class="c1">( -- d )</span> <span class="c1">( R: d -- d )</span>	<span class="c1">\ 将返回栈栈顶的双精度整数（两个元素）复制到参数栈。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nf">RDROP</span>	<span class="c1">( R: n -- )</span>				<span class="c1">\ 抛弃返回栈栈顶元素。
</span></span></span></code></pre></div><p>如果需要利用返回栈暂存结果，需注意如下几点<sup id="fnref:14"><a href="#fn:14" class="footnote-ref" role="doc-noteref">14</a></sup>:：</p>
<ol>
<li><code>&gt;R</code> 和 <code>R&gt;</code> 应当成对出现；</li>
<li>在使用 <code>EXIT</code> 或分号离开一个定义之前，返回栈应当恢复成它原来的状态；</li>
<li>任何在进入有限循环之前压入返回栈的数据在循环中是接触不到的；</li>
<li>任何在进入有限循环之后压入返回栈的数据会使循环变量 <code>I</code>、<code>J</code>、<code>K</code>、<code>L</code> 变得无法接触。</li>
</ol>
<h3 id="不定循环">不定循环</h3>
<p>Forth 中的不定循环结构有 <code>BEGIN</code>&hellip;<code>UNTIL</code>、<code>BEGIN</code>&hellip;<code>AGAIN</code> 和 <code>BEGIN</code>&hellip;<code>WHILE</code>&hellip;<code>REPEAT</code> 三种：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">BEGIN </span>	<span class="c1">( -- )</span>		<span class="c1">\ 开始一个不定循环。不定循环的结束位置由 UNTIL、AGAIN 或 REPEAT 标记。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">UNTIL	</span><span class="c1">( f -- )</span>	<span class="c1">\ 若 f 为假，则返回对应的 BEGIN 后面的第一个词继续执行；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">\ 若 f 为真，则退出循环，从 UNTIL 后面的第一个词继续执行。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">AGAIN	</span><span class="c1">( -- )</span>		<span class="c1">\ 返回对应的 BEGIN 后面的第一个词继续执行（无限循环）。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">WHILE	</span><span class="c1">( f -- )</span>	<span class="c1">\ 若 f 为假，则退出循环，从对应的 REPEAT 后面的第一个词继续执行；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">\ 若 f 为真，则从 WHILE 后面的第一个词继续执行。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">REPEAT	</span><span class="c1">( -- )</span> 		<span class="c1">\ 返回对应的 BEGIN 后面的第一个词继续执行。
</span></span></span></code></pre></div><p>需要说明的是 <code>BEGIN</code> condition <code>WHILE</code> body <code>REPEAT</code> 这种循环形式。在这种结构中，<code>WHILE</code> 检查（并弹出）栈顶标志；若标志为真，则执行 body 后重新返回循环的开头执行 condition；若标志为假，则退出循环<sup id="fnref:15"><a href="#fn:15" class="footnote-ref" role="doc-noteref">15</a></sup>。</p>
<p>正如上面的命名所示，一般地，程序段 condition 生成需检查的标志，body 中进行实际的操作。如清空栈内所有元素的 <code>CLEAR</code> 可以这样定义<sup id="fnref:16"><a href="#fn:16" class="footnote-ref" role="doc-noteref">16</a></sup>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">clear</span> <span class="c1">( [s] -- )</span>
</span></span><span class="line"><span class="cl">   <span class="k">begin </span> <span class="k">depth </span> <span class="k">while	</span><span class="c1">\ 用栈内元素数作为标志
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">drop	</span>			<span class="c1">\ 若栈内元素数不为 0，则弹出一个...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">repeat ;	</span>			<span class="c1">\ ...并循环上述操作。
</span></span></span></code></pre></div><h2 id="执行标记立即模式与编译模式编译时行为与执行时行为">执行标记，立即模式与编译模式，编译时行为与执行时行为</h2>
<p>Forth 系统中每个词对应一个<strong>执行标记</strong>（execution token）。执行标记是一个值，在大部分 Forth 系统中大小为 1 个单元，栈表示法中简写为 <code>xt</code>。执行标记对应词的执行时行为，用下面即将介绍的 <code>EXECUTE</code> 执行一个词的 <code>xt</code> 和在 Forth 解释器中运行一个词的行为完全相同。在 My4TH Forth （以及大部分 Forth 系统）中，一个词的执行标记就是该词的机器码程序的入口地址。</p>
<p>读者也许已经发现，分支与循环使用的词必须在 <code>:</code> 和 <code>;</code> 之间使用。这引出了编译模式与立即模式的概念。</p>
<p>Forth 解释器默认处于<strong>立即模式</strong>（immediate mode）。此时解释器按“表达式的计算”一节中描述的行为工作，执行输入流中的每一个词。</p>
<p><code>:</code> 使解释器切换到<strong>编译模式</strong>（compile mode）。在编译模式下，解释器遇到输入流中的数字和（普通的）词时，会在堆中分配空间，并将对应的<strong>代码</strong>（code，这里指机器语言的程序）写入该空间（这一过程称作<strong>生成</strong>（emit）代码。）。具体来说，在 My4TH Forth 中，写入的是数字压栈的代码或转子程序到词对应的执行标记的代码（<code>My4TH</code> 汇编中写作<code>JSR xt</code>）。</p>
<p>有些特殊的词在编译模式下会立即执行，这些词称作<strong>立即词</strong>（immediate word）。分支与循环使用的词都是立即词，它们在编译模式下生成分支与循环需要的代码<sup id="fnref:17"><a href="#fn:17" class="footnote-ref" role="doc-noteref">17</a></sup>。<code>.&quot;</code> 也是立即词，在编译模式下，它会将输入流后面到 <code>&quot;</code> 为止的字符串存入堆中，并生成打印它们的代码。</p>
<p>这引入了词的<strong>编译时行为</strong>（compilation semantics）和<strong>执行时行为</strong>（execution semantics）的概念。编译时行为就是词在冒号定义中使用时的行为：普通词具有<strong>缺省的编译时行为</strong>，即在堆中分配空间，并将 <code>JSR xt</code> 写入该空间；立即词具有非缺省的编译时行为，因词而异。执行时行为是执行通过冒号定义新造的词的时候，其中用到的已定义的词对应的行为。词的执行时行为因词而异（对于普通词，就是执行 <code>JSR xt</code>，也就是转子程序到词对应的执行标记，与在立即模式下运行这个词的行为相同）。</p>
<p>这样，在编译模式下，解释器<sup id="fnref:18"><a href="#fn:18" class="footnote-ref" role="doc-noteref">18</a></sup>会现场生成 <code>:</code> 到 <code>;</code> 之间的 Forth 程序对应的代码。与其他解释型语言的解释器不同，编译完成后，在立即模式下执行一个词时，不再有将程序现场翻译成机器码的环节，而是直接执行机器语言的程序。这样，<strong>Forth 语言用解释型语言的交互性，实现了编译型语言的运行速度</strong>。</p>
<p>显然，Forth 词的代码，往往由一系列转子程序（<code>JSR</code>）的指令组成。这种组织代码的方式像用一条线（thread） 将一系列子程序连接起来，称作<a href="https://www.complang.tuwien.ac.at/forth/threaded-code.html"><strong>穿线式代码</strong></a>（threaded code）。穿线式代码有很高的代码密度，十分节约内存。因此 Forth 程序往往比其他高级语言编写的程序更小，非常适用于嵌入式系统。</p>
<p>穿线式代码有不止一种实现方式。严格来讲，上面提到的实现方式称作<strong>子例程穿线式代码</strong>（subroutine threaded code）。常见的其他方式尚有<strong>间接穿线式代码</strong>（indirect threaded code）和<strong>直接穿线式代码</strong>（direct threaded code）。这两种实现方式下，定义的程序的代码部分由一系列地址而非直接由 <code>JSR</code> 指令组成，Forth 系统中使用专门的机器语言子程序（一般称作 <code>ENTER</code>）来执行代码部分。这几种实现方式各有优缺点，可参考<a href="https://www.bradrodriguez.com/papers/moving1.htm">这里</a>。</p>
<p>My4TH Forth 中，词典在内存中的格式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="line"><span class="cl">		  +----------------------------------+
</span></span><span class="line"><span class="cl">		  |                   xt             ￬                     xt
</span></span><span class="line"><span class="cl">		+----+------+---------+----+----+    +----+------+---------+----+----+
</span></span><span class="line"><span class="cl">content	|link|length|word_name|code|data|    |link|length|word_name|code|data|
</span></span><span class="line"><span class="cl">length	| 2  |  1   | length  | x1 |0~x2|    +----+------+---------+----+----+
</span></span><span class="line"><span class="cl">		+----+------+---------+----+----+
</span></span><span class="line"><span class="cl">				word n									word n-1
</span></span></code></pre></div><p>其中 <code>link</code> 是指向上一个词开始地址的指针。<code>length</code> 的最高位标识一个词是否为立即词。每一个词的 <code>xt</code> 是它的代码部分的起始地址。<code>data</code> 部分由 <code>ALLOT</code>、 <code>,</code> 和 <code>C,</code> 等词分配<sup id="fnref:19"><a href="#fn:19" class="footnote-ref" role="doc-noteref">19</a></sup>。词在词典中形成链表，解释器可以方便地对词典进行遍历。为加快查找词的速度，My4TH Forth 中的词典有 8 个入口点（entry point），并将词按名称长度分配到每个入口点。</p>
<p>控制解释器模式常用的词如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">name</span>		<span class="c1">( -- )</span>			<span class="c1">\ 定义一个词 name，定义以 ; 结束。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">:NONAME	</span>	<span class="c1">( -- xt )</span>		<span class="c1">\ 定义一个无名词，将其 xt 压入栈中。定义以 ; 结束。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="c1">\ : 和 :NONAME 会让解释器进入编译模式。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">;	</span>		<span class="c1">( -- )</span>			<span class="c1">\ 结束一个定义。将解释器切换回立即模式。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">[</span>			<span class="c1">( -- )</span>			<span class="c1">\ 将解释器切换到立即模式。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">]</span>			<span class="c1">( -- )</span>			<span class="c1">\ 将解释器切换到编译模式。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">LITERAL	</span>	<span class="c1">( x -- )</span> 	<span class="c1">\ 将栈顶元素作为字面量（也就是定义中直接出现的数字）编译进程序。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">2LITERAL	</span><span class="c1">( x1 x2 -- )</span>	<span class="c1">\ 将栈顶的两个元素作为字面量编译进程序。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">IMMEDIATE	</span><span class="c1">( -- )</span>			<span class="c1">\ 将最近定义的词标记为立即词。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">STATE	</span>	<span class="c1">( -- a-addr )</span>	<span class="c1">\ a-addr 中存储解释器的当前模式，真为编译模式，假为立即模式。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="c1">\ 能够改变 STATE 的值的词只有：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="c1">\ `:`、`;`、`ABORT`、`QUIT`、`:NONAME`、`[` 和 `]`。
</span></span></span></code></pre></div><p><code>[</code> 与 <code>]</code> 常在编译模式下使用，用于将解释器临时切换到立即模式。</p>
<p>很多时候，为了执行效率，要将某些多次运行中结果不变的操作（尤其是常数运算）在编译时执行。此时可用 <code>[</code> 和 <code>]</code> 将常数运算部分包裹起来（注意它们都是词，所以前后必须都有空格）。</p>
<p>此时常用的方法是：<code>[</code>&hellip;<code>]</code> 部分的运算将 1 个结果推入栈，然后用 <code>LITERAL</code><sup id="fnref:20"><a href="#fn:20" class="footnote-ref" role="doc-noteref">20</a></sup> 将栈顶元素编译进程序。如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">test1</span>  <span class="nf">[</span> <span class="mi">3</span> <span class="mi">4</span> <span class="k">* </span><span class="nf">]</span> <span class="k">literal ;
</span></span></span></code></pre></div><p>与</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">test2</span>  <span class="mi">12</span> <span class="k">;
</span></span></span></code></pre></div><p>生成的代码完全一样。甚至</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">12</span> <span class="kn">:</span> <span class="nc">test3</span>  <span class="k">literal ;
</span></span></span></code></pre></div><p>或者</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">3</span> <span class="mi">4</span> <span class="k">* </span><span class="kn">:</span> <span class="nc">test4</span>  <span class="k">literal ; </span>
</span></span></code></pre></div><p>也可以生成完全一样的代码，都是将常数 <code>12</code> 直接压栈。而</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">test-slow</span>  <span class="mi">3</span> <span class="mi">4</span> <span class="k">* ;
</span></span></span></code></pre></div><p>的效果也是将 <code>12</code> 压栈，但是每执行一次就要计算一次乘法，所以其速度大大慢于上述四个例子。</p>
<p>注意 <code>:NONAME</code> 可能在编译一开始（而不是遇到 <code>;</code> 时）就将 <code>xt</code> 压栈。所以上述 <code>LITERAL</code> 的例子中，<code>test3</code> 与 <code>test4</code> 不能用 <code>:NONAME</code> 代替 <code>:</code>。</p>
<h3 id="对执行标记的基本操作">对执行标记的基本操作</h3>
<p>执行标记的基本用途当然是执行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">EXECUTE	</span>	<span class="c1">( xt -- )</span>	<span class="c1">\ 执行 xt 标记的代码。
</span></span></span></code></pre></div><p>My4TH Forth 中，执行标记是一段机器码程序的入口地址。My4TH Forth 允许执行从内存任意地址开始的代码。例如，在  <code>My4TH</code> 中，复位程序的入口是 <code>$2D00</code>。所以 <code>$2d00 execute</code> 可以触发系统复位：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mh">$2d00</span> <span class="nf">execute↵</span> <span class="nf">EEPROMs:</span> <span class="nf">xxxxxx</span>
</span></span><span class="line"><span class="cl"><span class="nf">My4TH(xxx)</span> <span class="nf">v1.4</span> <span class="k">/ </span><span class="nf">xx</span> <span class="nf">MHz</span>
</span></span></code></pre></div><p>获取词的执行标记可以使用词 <code>'</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="nf">&#39;</span> <span class="nf">name</span>		<span class="c1">( -- xt )</span> 	<span class="c1">\ 获取词 name 的执行标记。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">[&#39;]	</span><span class="nf">name</span>				<span class="c1">\ 在编译时使用，作用与 [ &#39; name ] LITERAL 相同。
</span></span></span></code></pre></div><p>显然，在立即模式下，<code>' xyz EXECUTE</code> 与 <code>xyz</code> 的作用相同。</p>
<p>下面是 <code>'</code> 和 <code>EXECUTE</code> 的几个简单例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">greet</span>  <span class="s">.&#34;</span> <span class="s">Hello, I speak Forth.</span><span class="nf">&#34;</span> <span class="nf">;↵</span>  <span class="nf">ok</span>     
</span></span><span class="line"><span class="cl"><span class="nf">greet↵</span> <span class="nf">Hello,</span> <span class="k">I </span><span class="nf">speak</span> <span class="nf">Forth.</span> <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="nf">&#39;</span> <span class="nf">greet</span> <span class="nf">u.↵</span> <span class="mi">33848</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="nf">&#39;</span> <span class="nf">greet</span> <span class="nf">execute↵</span> <span class="nf">Hello,</span> <span class="k">I </span><span class="nf">speak</span> <span class="nf">Forth.</span> <span class="nf">ok</span> 
</span></span><span class="line"><span class="cl"><span class="nf">&#39;</span> <span class="nf">greet</span> <span class="mi">32</span> <span class="nf">dump↵</span>	
</span></span><span class="line"><span class="cl"><span class="mi">8438</span><span class="kn">:</span> <span class="nc">1E</span> <span class="mi">18</span> <span class="mi">52</span> <span class="mi">84</span> <span class="mi">48</span> <span class="mi">65</span> <span class="mi">6</span><span class="nf">C</span> <span class="mi">6</span><span class="nf">C</span> <span class="mi">6</span><span class="nf">F</span> <span class="mi">2</span><span class="nf">C</span> <span class="mi">20</span> <span class="mi">49</span> <span class="mi">20</span> <span class="mi">73</span> <span class="mi">70</span> <span class="mi">65</span>  <span class="kt">..</span><span class="nf">R.Hello,</span> <span class="k">I </span><span class="nf">spe</span>         
</span></span><span class="line"><span class="cl"><span class="mi">8448</span><span class="kn">:</span> <span class="nc">61</span> <span class="mi">6</span><span class="nf">B</span> <span class="mi">20</span> <span class="mi">46</span> <span class="mi">6</span><span class="nf">F</span> <span class="mi">72</span> <span class="mi">74</span> <span class="mi">68</span> <span class="mi">2</span><span class="nf">E</span> <span class="mi">00</span> <span class="mi">01</span> <span class="mi">0</span><span class="nf">D</span> <span class="mi">84</span> <span class="mi">01</span> <span class="mi">0</span><span class="nf">C</span> <span class="mi">3</span><span class="nf">C</span>  <span class="nf">ak</span> <span class="nf">Forth.......&lt;</span>         
</span></span><span class="line"><span class="cl"> <span class="nf">ok</span>    
</span></span><span class="line"><span class="cl"> <span class="nf">&#39;</span> <span class="nf">greet</span> <span class="mi">16</span> <span class="k">- </span><span class="mi">48</span> <span class="nf">dump↵</span>
</span></span><span class="line"><span class="cl"><span class="mi">8428</span><span class="kn">:</span> <span class="nc">70</span> <span class="nf">CF</span> <span class="nf">B6</span> <span class="mi">39</span> <span class="mi">1</span><span class="nf">C</span> <span class="mi">45</span> <span class="mi">76</span> <span class="mi">80</span> <span class="mi">3</span><span class="nf">A</span> <span class="mi">63</span> <span class="mi">05</span> <span class="mi">67</span> <span class="mi">72</span> <span class="mi">65</span> <span class="mi">65</span> <span class="mi">74</span>  <span class="nf">p..9.Ev.:c.greet</span>         
</span></span><span class="line"><span class="cl"><span class="mi">8438</span><span class="kn">:</span> <span class="nc">1E</span> <span class="mi">18</span> <span class="mi">52</span> <span class="mi">84</span> <span class="mi">48</span> <span class="mi">65</span> <span class="mi">6</span><span class="nf">C</span> <span class="mi">6</span><span class="nf">C</span> <span class="mi">6</span><span class="nf">F</span> <span class="mi">2</span><span class="nf">C</span> <span class="mi">20</span> <span class="mi">49</span> <span class="mi">20</span> <span class="mi">73</span> <span class="mi">70</span> <span class="mi">65</span>  <span class="kt">..</span><span class="nf">R.Hello,</span> <span class="k">I </span><span class="nf">spe</span>         
</span></span><span class="line"><span class="cl"><span class="mi">8448</span><span class="kn">:</span> <span class="nc">61</span> <span class="mi">6</span><span class="nf">B</span> <span class="mi">20</span> <span class="mi">46</span> <span class="mi">6</span><span class="nf">F</span> <span class="mi">72</span> <span class="mi">74</span> <span class="mi">68</span> <span class="mi">2</span><span class="nf">E</span> <span class="mi">00</span> <span class="mi">01</span> <span class="mi">0</span><span class="nf">D</span> <span class="mi">84</span> <span class="mi">01</span> <span class="mi">0</span><span class="nf">C</span> <span class="mi">3</span><span class="nf">C</span>  <span class="nf">ak</span> <span class="nf">Forth.......&lt;</span>         
</span></span><span class="line"><span class="cl"> <span class="nf">ok</span>    
</span></span></code></pre></div><p>下面的例子可以更直观地说明普通词 <code>'</code> 和立即词 <code>[']</code> 的区别：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">test</span>  <span class="s">.&#34;</span> <span class="s">Test.</span><span class="nf">&#34;</span> <span class="nf">;↵</span>  <span class="nf">ok</span> 
</span></span><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">test&#39;</span>  <span class="nf">&#39;</span> <span class="nf">test</span> <span class="nf">;↵</span>  <span class="nf">ok</span> 
</span></span><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">test[&#39;]</span>  <span class="k">[&#39;] </span><span class="nf">test</span> <span class="nf">;↵</span>  <span class="nf">ok</span> 
</span></span><span class="line"><span class="cl"><span class="nf">test&#39;↵</span>  <span class="nf">?</span> <span class="nf">syntax</span>		<span class="c1">\ test 执行到 &#39; 时，需要输入流中的 name. 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>						<span class="c1">\ 此时输入流中没有 name，因此报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">test&#39;</span> <span class="nf">test↵</span> <span class="nf">Test.</span> <span class="nf">ok</span>	<span class="c1">\ 输入流中有 test，此时执行的效果相当于 &#34; &#39; test test &#34;.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>						<span class="c1">\ &#39; test 获取 test 的 xt, 第二个 test 在屏幕上打印 &#34;Test.&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">.</span><span class="nf">s↵</span> <span class="nf">&lt;1&gt;</span> <span class="mi">-31188</span>  <span class="nf">ok</span>		<span class="c1">\ 栈内的内容是 &#39; test 留下的 test 的 xt.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">.</span><span class="nf">↵</span> <span class="mi">-31188</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="nf">test[&#39;]↵</span>  <span class="nf">ok</span> 			<span class="c1">\ [&#39;] test 在编译时就取得了 test 的 xt. 执行时将其压栈。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">.s </span><span class="nf">&lt;1&gt;</span> <span class="mi">-31188</span>  <span class="nf">ok</span>
</span></span></code></pre></div><p>与将数据放进内存的 <code>,</code> 相对应，进行对执行标记“编译”这一操作（在使用子例程穿线式代码的 My4TH Forth 中，也就是将执行标记对应的 <code>JSR xt</code> 放在 <code>HERE</code> 处并分配相应内存）的词是 <code>COMPILE,</code><sup id="fnref:21"><a href="#fn:21" class="footnote-ref" role="doc-noteref">21</a></sup>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">COMPILE,	</span><span class="c1">( xt -- )</span> 	<span class="c1">\ 将运行执行标记 xt 的代码片段编译进程序。
</span></span></span></code></pre></div><p>用 <code>CREATE</code> 创建的词也有执行标记。可以用 <code>&gt;BODY</code><sup id="fnref:22"><a href="#fn:22" class="footnote-ref" role="doc-noteref">22</a></sup> 来获得 <code>CREATE</code> 创建的词的数据区域的地址：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">&gt;BODY	</span><span class="c1">( xt -- a-addr )</span>	<span class="c1">\ 从 xt 获得 CREATE 创建的词（后面紧跟）的数据区域的地址，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="c1">\ 也就是刚 CREATE 该词之后 HERE 的地址。
</span></span></span></code></pre></div><h3 id="推迟执行postpone">推迟执行（POSTPONE）</h3>
<p>立即词在编译时立即执行。然而有时需要将立即词的编译时行为编译进程序，此时应使用 <code>POSTPONE</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">POSTPONE word	</span><span class="c1">( -- )</span>	<span class="c1">\ 将词 word 的编译时行为编译进正在定义的程序，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>						<span class="c1">\ 使其推迟到程序执行时执行。
</span></span></span></code></pre></div><p>例如，想给前面提到的 <code>THEN</code> 起一个别名 <code>ENDIF</code>，可以这样做：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">endif</span>  <span class="k">postpone then ; </span><span class="nf">immediate↵</span>  <span class="nf">ok</span>	<span class="c1">\ then 本身是立即词，因此 endif 也应该是立即词
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">:</span> <span class="nc">test</span>  <span class="k">0&gt; if </span><span class="s">.&#34;</span> <span class="s">Greater than zero.</span><span class="nf">&#34;</span> <span class="k">else </span><span class="s">.&#34;</span> <span class="s">Not greater than zero.</span><span class="nf">&#34;</span> <span class="nf">endif</span> <span class="nf">;↵</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">100</span> <span class="nf">test↵</span> <span class="nf">Greater</span> <span class="nf">than</span> <span class="nf">zero.</span> <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">-100</span> <span class="nf">test↵</span> <span class="nf">Not</span> <span class="nf">greater</span> <span class="nf">than</span> <span class="nf">zero.</span> <span class="nf">ok</span>	<span class="c1">\ endif 与 then 起的作用完全相同
</span></span></span></code></pre></div><p>注意在这个例子中 <code>ENDIF</code> 是立即词，（在冒号定义中）使用 <code>ENDIF</code> 时执行的是 <code>then</code> 的编译时行为。</p>
<p>如果 <code>POSTPONE</code> 一个普通词，那么推迟执行的是这个普通词<strong>缺省的编译时行为</strong>（在堆中分配空间，并将 <code>JSR xt</code> 写入该空间）。</p>
<p>例如，Gforth 系统提供了 <code>+DO</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="nf">+DO</span>	 	<span class="c1">( lim n -- )</span>	<span class="c1">\ 先判断 n 和 lim 的关系。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>						<span class="c1">\ 若 lim&lt;=n，则直接跳到对应的 LOOP 或 +LOOP 后面；否则与 DO 相同。
</span></span></span></code></pre></div><p>如果想在 My4TH Forth 中使用这一词，可以这样定义：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">+do</span> <span class="c1">( lim n -- )</span> <span class="k">POSTPONE over </span> <span class="k">POSTPONE min </span> <span class="k">POSTPONE ?do </span> <span class="k">; immediate
</span></span></span></code></pre></div><p>其中 <code>over</code> 和 <code>min</code> 是普通词，<code>?do</code> 是立即词，<code>+do</code> 本身是立即词。在冒号定义中使用 <code>+DO</code> 这个立即词时，会将 <code>over</code> 和 <code>min</code> 编译进程序（执行它们缺省的编译时行为），然后执行 <code>?do</code> 的编译时行为。</p>
<p>因此，下面的两个词的作用完全相同：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">test1</span> <span class="c1">( lim n -- )</span> <span class="nf">+do</span>  <span class="k">i . loop ;
</span></span></span><span class="line"><span class="cl"><span class="k"></span><span class="kn">:</span> <span class="nc">test2</span> <span class="c1">( lim n -- )</span> <span class="k">over min ?do </span> <span class="k">i . loop ;
</span></span></span></code></pre></div><p>前面提到的 <code>COMPILE,</code> 可以这么定义<sup id="fnref:23"><a href="#fn:23" class="footnote-ref" role="doc-noteref">23</a></sup>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">compile,</span> <span class="c1">( xt -- )</span> <span class="k">postpone literal </span> <span class="k">postpone execute ;
</span></span></span></code></pre></div><p>词 <code>[COMPILE]</code><sup id="fnref:24"><a href="#fn:24" class="footnote-ref" role="doc-noteref">24</a></sup> 只推迟执行立即词：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">[COMPILE] word	</span><span class="c1">( -- )</span>	<span class="c1">\ 如果词 word 是普通词（具有缺省的编译时行为），
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>						<span class="c1">\ 则相当于 word 本身；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>						<span class="c1">\ 如果词 word 是立即词（具有非缺省的编译时行为），
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>						<span class="c1">\ 则相当于 POSTPONE word。
</span></span></span></code></pre></div><h3 id="向量执行">向量执行</h3>
<p>可以使用 <code>'</code> 取得执行标记并将其保存在变量中，后续使用 <code>EXECUTE</code> 执行。这一技巧称作<strong>向量执行</strong>（vectored execution）。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">variable</span> <span class="nc">v↵</span>  <span class="nf">ok</span>                                                                  
</span></span><span class="line"><span class="cl"><span class="nf">&#39;</span> <span class="nf">greet</span> <span class="nf">v</span> <span class="nf">!↵</span>  <span class="nf">ok</span>	<span class="c1">\ greet 是“对执行标记的基本操作”一节中定义的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">v</span> <span class="k">@ </span><span class="nf">execute↵</span> <span class="nf">Hello,</span> <span class="k">I </span><span class="nf">speak</span> <span class="nf">Forth.</span> <span class="nf">ok</span> 
</span></span></code></pre></div><p>下面的例子中，词 <code>aloha</code> 的行为由变量 <code>'aloha</code> 的内容决定：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">hello</span>  <span class="s">.&#34;</span> <span class="s">Hello</span><span class="nf">&#34;</span> <span class="k">;
</span></span></span><span class="line"><span class="cl"><span class="k"></span><span class="kn">:</span> <span class="nc">goodbye</span>  <span class="s">.&#34;</span> <span class="s">Goodbye</span><span class="nf">&#34;</span> <span class="k">;
</span></span></span><span class="line"><span class="cl"><span class="k"></span><span class="kn">variable</span> <span class="nc">&#39;aloha</span>   <span class="nf">&#39;</span> <span class="nf">hello</span> <span class="nf">&#39;aloha</span> <span class="k">!
</span></span></span><span class="line"><span class="cl"><span class="k"></span><span class="kn">:</span> <span class="nc">aloha</span>  <span class="nf">&#39;aloha</span> <span class="k">@ execute ;
</span></span></span></code></pre></div><p>此时执行 <code>aloha</code>，由于变量 <code>'aloha</code> 中存储的内容为 <code>hello</code> 的执行标记，故其作用与直接执行 <code>hello</code> 相同：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="nf">aloha↵</span> <span class="nf">Hello</span> <span class="nf">ok</span>
</span></span></code></pre></div><p>词 <code>say</code> 的作用为将输入流中下一个词的执行标记存入 <code>'aloha</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">say</span>  <span class="nf">&#39;</span> <span class="nf">&#39;aloha</span> <span class="k">! ;
</span></span></span></code></pre></div><p>这样，我们可以用容易理解的方式改变 <code>aloha</code> 的行为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="nf">say</span> <span class="nf">goodbye↵</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="nf">aloha↵</span> <span class="nf">Goodbye</span> <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="nf">say</span> <span class="nf">hello↵</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="nf">aloha↵</span> <span class="nf">Hello</span> <span class="nf">ok</span>
</span></span></code></pre></div><p>这里有两点需要指出：</p>
<ol>
<li>
<p>前面已多次提到，在定义中使用 <code>'</code> 这种需要从输入流中取得下一个记号 <code>name</code> 的词，需要的记号会在执行时而不是定义时取得。<code>CREATE</code>&hellip;<code>DOES&gt;</code> 的行为也符合这一点。</p>
</li>
<li>
<p>Forth 的词的名称可以包含任何除分隔符外的字符，如变量 <code>'aloha</code>。注意变量 <code>'aloha</code> 的 <code>'</code> 后面没有空格，这里的 <code>'</code> 只是用来提示程序的读者，变量中存储的内容是执行标记。</p>
</li>
</ol>
<p>向量执行更典型的用法是将一系列词的执行标记存储在表格中，根据某一数值选择性执行。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">range</span> <span class="c1">( n min max -- n1 )</span> <span class="c1">\ if min&lt;=n&lt;max, n1=n; else n1=0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="mi">2</span> <span class="k">pick </span><span class="nf">-rot</span> <span class="k">within 0= if </span> <span class="k">drop </span><span class="mi">0</span>  <span class="k">then ;
</span></span></span><span class="line"><span class="cl"><span class="k"></span><span class="kn">:</span> <span class="nc">button?</span> <span class="c1">( -- button )</span>     
</span></span><span class="line"><span class="cl">   <span class="k">key </span><span class="mi">48</span> <span class="k">-	</span><span class="c1">\ 词 KEY 等待键盘输入，并返回按下按键的 ASCII 码。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">\ ASCII 码减去 48，将 0~9 的字符转换为数字。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="mi">1</span> <span class="mi">6</span> <span class="nf">range</span> <span class="k">;	</span><span class="c1">\ 如果按下的按键在 1~5 之间，则返回按键代号；否则返回 0。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">\ 为按键 1~5 执行的操作以及按下其他按键执行的操作定义词。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">:</span> <span class="nc">btn1</span> <span class="s">.&#34;</span> <span class="s">Button 1 Pressed.</span><span class="nf">&#34;</span> <span class="k">;
</span></span></span><span class="line"><span class="cl"><span class="k"></span><span class="kn">:</span> <span class="nc">btn2</span> <span class="s">.&#34;</span> <span class="s">Button 2 Pressed.</span><span class="nf">&#34;</span> <span class="k">;
</span></span></span><span class="line"><span class="cl"><span class="k"></span><span class="kn">:</span> <span class="nc">btn3</span> <span class="s">.&#34;</span> <span class="s">Button 3 Pressed.</span><span class="nf">&#34;</span> <span class="k">;
</span></span></span><span class="line"><span class="cl"><span class="k"></span><span class="kn">:</span> <span class="nc">btn4</span> <span class="s">.&#34;</span> <span class="s">Button 4 Pressed.</span><span class="nf">&#34;</span> <span class="k">;
</span></span></span><span class="line"><span class="cl"><span class="k"></span><span class="kn">:</span> <span class="nc">btn5</span> <span class="s">.&#34;</span> <span class="s">Button 5 Pressed.</span><span class="nf">&#34;</span> <span class="k">;
</span></span></span><span class="line"><span class="cl"><span class="k"></span><span class="kn">:</span> <span class="nc">btn0</span> <span class="s">.&#34;</span> <span class="s">Others Pressed.</span><span class="nf">&#34;</span> <span class="k">; </span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">\ 创建数组 buttons，将上述词的 xt 存入数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">create </span><span class="nf">buttons</span>  <span class="nf">&#39;</span> <span class="nf">btn0</span> <span class="k">, </span><span class="nf">&#39;</span> <span class="nf">btn1</span> <span class="k">, </span><span class="nf">&#39;</span> <span class="nf">btn2</span> <span class="k">, </span><span class="nf">&#39;</span> <span class="nf">btn3</span> <span class="k">, </span><span class="nf">&#39;</span> <span class="nf">btn4</span> <span class="k">,
</span></span></span><span class="line"><span class="cl"><span class="k"></span>   <span class="nf">&#39;</span> <span class="nf">btn5</span> <span class="k">, </span>    
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="c1">\ 词 button 首先取得按键编号(0 或 1~5)，然后从数组中取得对应词的 xt 并执行。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">:</span> <span class="nc">button</span> <span class="c1">( -- )</span> <span class="nf">button?</span> <span class="k">cells </span><span class="nf">buttons</span> <span class="k">+ @ execute ; </span> 
</span></span></code></pre></div><p>按下 1~5 的按键时，上述程序会执行 <code>btn1~btn5</code> 中对应的词；按下其他按键时，会执行 <code>btn0</code>。</p>
<p>显然，这一程序也可用 <code>CASE</code> 实现<sup id="fnref:25"><a href="#fn:25" class="footnote-ref" role="doc-noteref">25</a></sup>。不过向量执行更加灵活：上述例子中数组 <code>buttons</code> 中的元素在运行时可随意更改，而 <code>CASE</code> 想要实现随意更改，必须再套一层向量执行，或使用下面将要介绍的 <code>DEFER</code>。这增加了程序的复杂程度，不是最佳的实现方式。</p>
<p>上述例子中，如果词 <code>btn1</code>&hellip;<code>btn5</code> 不在别处使用，也可用 <code>:NONAME</code> 对其进行定义：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="c1">\ 为按键 1~5 执行的操作以及按下其他按键执行的操作定义无名词。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">:noname </span> <span class="s">.&#34;</span> <span class="s">Button 5 Pressed.</span><span class="nf">&#34;</span> <span class="k">;
</span></span></span><span class="line"><span class="cl"><span class="k">:noname </span> <span class="s">.&#34;</span> <span class="s">Button 4 Pressed.</span><span class="nf">&#34;</span> <span class="k">;
</span></span></span><span class="line"><span class="cl"><span class="k">:noname </span> <span class="s">.&#34;</span> <span class="s">Button 3 Pressed.</span><span class="nf">&#34;</span> <span class="k">;
</span></span></span><span class="line"><span class="cl"><span class="k">:noname </span> <span class="s">.&#34;</span> <span class="s">Button 2 Pressed.</span><span class="nf">&#34;</span> <span class="k">;
</span></span></span><span class="line"><span class="cl"><span class="k">:noname </span> <span class="s">.&#34;</span> <span class="s">Button 1 Pressed.</span><span class="nf">&#34;</span> <span class="k">;
</span></span></span><span class="line"><span class="cl"><span class="k">:noname </span> <span class="s">.&#34;</span> <span class="s">Others Pressed.</span><span class="nf">&#34;</span> <span class="k">; </span> 
</span></span><span class="line"><span class="cl"><span class="c1">\ 注意 : 和 noname 之间没有空格，否则会定义一个名为 noname 的词
</span></span></span><span class="line"><span class="cl"><span class="c1">( btn5 btn4 btn3 btn2 btn1 btn0 )</span>
</span></span><span class="line"><span class="cl"><span class="c1">\ 创建数组 buttons，将栈内的 xt 存入数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">create </span><span class="nf">buttons</span>  <span class="k">, , , , , ,	</span><span class="c1">\ 注意之前 :noname 的顺序以及 , 的数量都应当正确
</span></span></span></code></pre></div><h3 id="可执行变量defer">可执行变量，<code>DEFER</code></h3>
<p>有时需要处理单个的执行向量。此时使用 <code>DEFER</code> 更加清晰简洁：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">DEFER </span><span class="nf">defer-name</span>	<span class="c1">( -- )</span>	<span class="c1">\ 定义一个名为 defer-name 的可执行变量。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="c1">\ 可执行变量可以像其他词一样执行。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="c1">\ 在 My4TH Forth 中，其缺省行为为空操作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">IS </span><span class="nf">defer-name</span>	<span class="c1">( xt -- )</span>	<span class="c1">\ 将 xt 存入可执行变量 defer-name。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="c1">\ 执行 defer-name 时，执行 xt 开始的代码。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">ACTION-OF </span><span class="nf">defer-name</span> <span class="c1">( -- xt )</span>	<span class="c1">\ 取得可执行变量 defer-name 的执行行为的 xt。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">DEFER@	</span>	<span class="c1">( xt1 -- xt2 )</span>	<span class="c1">\ xt1 是可执行变量本身的 xt，可通过 &#39; defer-name 取得。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="c1">\ xt2 是可执行变量的执行行为的 xt。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">DEFER!	</span>	<span class="c1">( xt2 xt1 -- )</span>	<span class="c1">\ 将 xt1 对应的可执行变量的执行行为设置为 xt2 开始的代码。
</span></span></span></code></pre></div><p>使用 <code>DEFER</code> 的一个最典型的场合，是在排序和查找的程序中，由于数据类型的不同，比较两个数据使用的词也不同。下面是一个二分查找的例子（修改自 <a href="https://rosettacode.org/wiki/Binary_search#Forth">https://rosettacode.org/wiki/Binary_search#Forth</a> ）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">defer </span><span class="nf">(compare)</span>
</span></span><span class="line"><span class="cl"><span class="nf">&#39;</span> <span class="k">- is </span><span class="nf">(compare)</span> <span class="c1">\ 对于数字，设置 (compare) 的行为为 -
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">:</span> <span class="nc">mid</span> <span class="c1">( u l -- mid )</span> <span class="k">tuck - 2/ </span><span class="nf">cell</span> <span class="k">negate and + ;
</span></span></span><span class="line"><span class="cl"><span class="k"></span>
</span></span><span class="line"><span class="cl"><span class="c1">\ 每个 item 占 1 个单元。
</span></span></span><span class="line"><span class="cl"><span class="c1">\ item 可以是数字，也可以是指向其他数据类型的地址。
</span></span></span><span class="line"><span class="cl"><span class="c1">\ 如果是指向其他数据类型的地址，那么需要按需设置 (compare) 的行为。
</span></span></span><span class="line"><span class="cl"><span class="c1">\ 被查找的数组必须按 (compare) 排好序。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">:</span> <span class="nc">bsearch</span> <span class="c1">( item end start -- pos found? )</span>
</span></span><span class="line"><span class="cl">   <span class="k">rot &gt;r </span><span class="c1">( end start )</span> <span class="c1">( R:item )</span>
</span></span><span class="line"><span class="cl">   <span class="k">begin 2dup &gt; while </span>	<span class="c1">\ while end &gt; start
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">2dup </span><span class="c1">( end start end start )</span>
</span></span><span class="line"><span class="cl">      <span class="nf">mid</span> <span class="c1">( end start mid )</span>
</span></span><span class="line"><span class="cl">      <span class="k">dup @ </span><span class="c1">( end start mid mid-item )</span>
</span></span><span class="line"><span class="cl">	  <span class="k">r@ </span><span class="c1">( end start mid mid-item item )</span> 
</span></span><span class="line"><span class="cl">      <span class="nf">(compare)</span> 
</span></span><span class="line"><span class="cl">      <span class="k">0&lt; if </span><span class="c1">( end start mid )</span>
</span></span><span class="line"><span class="cl">         <span class="k">nip cell+ </span><span class="c1">( end mid+1 )</span>
</span></span><span class="line"><span class="cl">      <span class="k">else </span>
</span></span><span class="line"><span class="cl">         <span class="k">rot drop swap </span><span class="c1">( mid start )</span>
</span></span><span class="line"><span class="cl">      <span class="k">then </span>
</span></span><span class="line"><span class="cl">   <span class="k">repeat </span>
</span></span><span class="line"><span class="cl">   <span class="c1">( pos pos )</span> <span class="k">@ </span><span class="c1">( pos found-item )</span> <span class="k">r&gt; </span><span class="c1">( pos found-item item )</span>
</span></span><span class="line"><span class="cl">   <span class="nf">(compare)</span> <span class="k">if false else true then </span><span class="c1">( pos found? )</span> <span class="k">;
</span></span></span><span class="line"><span class="cl"><span class="k"></span>  
</span></span><span class="line"><span class="cl"><span class="nf">测试：</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl"><span class="k">create </span><span class="nf">test</span>  <span class="mi">2</span> <span class="k">, </span><span class="mi">4</span> <span class="k">, </span><span class="mi">6</span> <span class="k">, </span><span class="mi">9</span> <span class="k">, </span><span class="mi">11</span> <span class="k">, </span><span class="mi">99</span> <span class="k">,
</span></span></span><span class="line"><span class="cl"><span class="k"></span><span class="kn">:</span> <span class="nc">probe</span> <span class="c1">( n -- )</span> <span class="nf">test</span> <span class="mi">5</span> <span class="k">cells </span><span class="nf">bounds</span> <span class="nf">bsearch</span> <span class="k">. @ . ;
</span></span></span><span class="line"><span class="cl"><span class="k"></span><span class="c1">\ BOUNDS ( addr u –- addr+u addr ) 将首地址和长度转换为适合 do 或 ?do 使用的格式。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="nf">probe↵</span> <span class="mi">0</span> <span class="mi">2</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span> <span class="nf">probe↵</span> <span class="mi">-1</span> <span class="mi">2</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span> <span class="nf">probe↵</span> <span class="mi">0</span> <span class="mi">4</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">4</span> <span class="nf">probe↵</span> <span class="mi">-1</span> <span class="mi">4</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">10</span> <span class="nf">probe↵</span> <span class="mi">0</span> <span class="mi">11</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">11</span> <span class="nf">probe↵</span> <span class="mi">-1</span> <span class="mi">11</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">12</span> <span class="nf">probe↵</span> <span class="mi">0</span> <span class="mi">99</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">100</span> <span class="nf">probe↵</span> <span class="mi">0</span> <span class="mi">99</span>  <span class="nf">ok</span>
</span></span></code></pre></div><p>到这里，读者也许已经自行总结出 Forth 语言最重要的两大特点（来自 <em>Thinking Forth</em> 第一章）：</p>
<ul>
<li>
<p><strong>隐式调用</strong>：任何一个词从底层来看其实都是子程序调用，这里不需要像汇编语言一样书写出 <code>JSR</code> 或者 <code>CALL</code> 之类。与其他高级语言的关键字、运算符与函数调用相比，Forth 的词也具有更统一的行为：<code>,</code> 这种在其他语言中是分隔符的记号是一个词，<code>+</code> 这种在其他语言中是运算符的记号是一个词，<code>IF</code> 这种在其他语言中是关键字的记号是一个词，上面定义的 <code>bsearch</code> 这种在其他语言中是函数的记号是一个词，在其他语言中是常量或变量的记号也是一个词。词的实例行为及编译时行为有缺省值，也可以由编程者指定，这提供了最大的灵活性。</p>
</li>
<li>
<p><strong>隐式数据传递</strong>：输入流或者定义中的词之间的数据通过栈传递，不需要显式写出 <code>PUSH</code> 或 <code>POP</code>，以及其他语言中的参数列表或 <code>return</code>。只要词对栈的作用定义良好，那么程序天然就是模块化的。显然，词之间可以嵌套调用（定义一个词时，可以自由使用其他的词）。</p>
</li>
</ul>
<p>Forth 在<strong>语义的明确</strong>、<strong>执行的效率</strong>、<strong>实现的简单</strong>三者之间达到了一个较好的平衡。当然，这也让写出可读的程序更大程度上成为了编程者的责任。协调这三者之间的关系，也是编写 Forth 程序的一项重要原则。</p>
<h2 id="字符串操作">字符串操作</h2>
<h3 id="字符的编码">字符的编码</h3>
<p>My4TH Forth 的字符编码是 ASCII 码。词 <code>CHAR</code> 用于取得字符的编码。词 <code>BL</code> 用于取得空格的编码。</p>
<p>词 <code>PAD</code> 用来获取一段缓冲区的地址，这段缓冲区可以作为字符与字符串操作的临时存储区使用。Forth 2012 标准规定，缓冲区 <code>PAD</code> 的长度至少为 84 字节（My4TH Forth 中，缓冲区 <code>PAD</code> 的长度为 96 字节）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">CHAR </span><span class="nf">c</span>		<span class="c1">( -- n )</span>	<span class="c1">\ 取得字符 c 的编码 n。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">[CHAR] </span><span class="nf">c</span>				<span class="c1">\ 在编译时使用，相当于 [ CHAR c ] LITERAL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">BL	</span>		<span class="c1">( -- n )</span>	<span class="c1">\ 取得空格的编码 n (ASCII 码 32)。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">PAD	</span>		<span class="c1">( -- addr )</span>	<span class="c1">\ 取得一段缓冲区的地址 addr。缓冲区的长度至少为 84 字节。
</span></span></span></code></pre></div><h3 id="字符串的格式">字符串的格式</h3>
<p>词 <code>C&quot;</code> 用于编译一个<strong>带长度的字符串</strong>（counted string）。其格式如下<sup id="fnref:26"><a href="#fn:26" class="footnote-ref" role="doc-noteref">26</a></sup>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="line"><span class="cl">				    |←------- n bytes ------→|
</span></span><span class="line"><span class="cl">				+---+---+---+---+---+......+---+
</span></span><span class="line"><span class="cl">				| n |   |   |   |   |      |   |
</span></span><span class="line"><span class="cl">				+---+---+---+---+---+......+---+
</span></span><span class="line"><span class="cl">					￪
</span></span><span class="line"><span class="cl">result of COUNT: c-addr u=n
</span></span></code></pre></div><p>显而易见，存储一个长度为 n 的带长度的字符串需要 n+1 个字节的空间，而字符串最长的长度为 255。</p>
<p>Forth 中处理字符串的词往往要求栈中的<strong>首地址和长度</strong>二元组 <code>( c-addr u )</code>。这一二元组中，<code>c-addr</code> 指向字符串的第一个字符，<code>u</code> 为字符串长度。从带长度的字符串获得这一二元组使用词 <code>COUNT</code> 。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="s">C&#34;</span> <span class="s">string</span><span class="nf">&#34;</span>	<span class="c1">( -- c-addr )</span>	<span class="c1">\ 在编译时，将跟在后面直到下一个 `&#34;` 的字符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="c1">\ 编译成一个带长度的字符串；执行时将其地址 c-addr 压栈。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">COUNT	</span>	<span class="c1">( c-addr1 -- c-addr2 u )</span>	<span class="c1">\ 从带长度的字符串 c-addr1 获得二元组 c-addr2 u，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>										<span class="c1">\ 其中 c-addr2 指向字符串的第一个字符，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>										<span class="c1">\ u 为字符串长度。
</span></span></span></code></pre></div><p>显然，<code>COUNT</code> 可以这样定义：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">count</span> <span class="c1">( addr1 -- addr2 u )</span> 
</span></span><span class="line"><span class="cl">   <span class="k">dup	</span><span class="c1">( addr1 addr1 )</span>
</span></span><span class="line"><span class="cl">   <span class="k">1+	</span><span class="c1">( addr1 addr2 )</span>
</span></span><span class="line"><span class="cl">   <span class="k">swap	</span><span class="c1">( addr2 addr1 )</span>
</span></span><span class="line"><span class="cl">   <span class="k">c@ ;	</span><span class="c1">( addr2 u=length )</span>
</span></span></code></pre></div><p>用 <code>S&quot;</code> 和 <code>S\&quot;</code> 可直接获得字符串的 <code>( c-addr u )</code> 二元组<sup id="fnref:27"><a href="#fn:27" class="footnote-ref" role="doc-noteref">27</a></sup>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="s">S&#34;</span> <span class="s">string</span><span class="nf">&#34;</span>	<span class="c1">( -- c-addr u )</span>	<span class="c1">\ 编译时将跟在后面直到下一个`&#34;`的字符编译成一个字符串；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="c1">\ 执行时将其首地址和长度 c-addr u 压栈。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">S\&#34;</span> <span class="nf">string&#34;</span>	<span class="c1">( -- c-addr u )</span>	<span class="c1">\ 作用与 S&#34; 相同，允许转义字符`\`的使用。
</span></span></span></code></pre></div><p><code>S\&quot;</code> 使用的转义字符如下：</p>
<table>
  <thead>
      <tr>
          <th>转义字符</th>
          <th>名称</th>
          <th>作用</th>
          <th>ASCII码</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>\a</code></td>
          <td>BEL</td>
          <td>响铃</td>
          <td>7</td>
      </tr>
      <tr>
          <td><code>\b</code></td>
          <td>BS</td>
          <td>退格</td>
          <td>8</td>
      </tr>
      <tr>
          <td><code>\e</code></td>
          <td>ESC</td>
          <td>转义</td>
          <td>27</td>
      </tr>
      <tr>
          <td><code>\f</code></td>
          <td>FF</td>
          <td>另起一页</td>
          <td>12</td>
      </tr>
      <tr>
          <td><code>\l</code></td>
          <td>LF</td>
          <td>另起一行</td>
          <td>10</td>
      </tr>
      <tr>
          <td><code>\m</code></td>
          <td>CR/LF</td>
          <td>换行加回车</td>
          <td>13, 10</td>
      </tr>
      <tr>
          <td><code>\n</code></td>
          <td>newline</td>
          <td>换行</td>
          <td>与实现相关，可能是CR/LF, CR, LF, LF/CR 等</td>
      </tr>
      <tr>
          <td><code>\q</code></td>
          <td>double-quote</td>
          <td>双引号</td>
          <td>34</td>
      </tr>
      <tr>
          <td><code>\r</code></td>
          <td>CR</td>
          <td>回车</td>
          <td>13</td>
      </tr>
      <tr>
          <td><code>\t</code></td>
          <td>HT</td>
          <td>横向制表符(TAB)</td>
          <td>8</td>
      </tr>
      <tr>
          <td><code>\v</code></td>
          <td>VT</td>
          <td>纵向制表符</td>
          <td>11</td>
      </tr>
      <tr>
          <td><code>\z</code></td>
          <td>NUL</td>
          <td>空字符</td>
          <td>0</td>
      </tr>
      <tr>
          <td><code>\&quot;</code></td>
          <td>double-quote</td>
          <td>双引号</td>
          <td>34</td>
      </tr>
      <tr>
          <td>\xaf</td>
          <td></td>
          <td>任意字符。af 是一个 16 进制数字（00&hellip;ff）</td>
          <td>ASCII 十六进制为 af 的字符</td>
      </tr>
      <tr>
          <td><code>\\</code></td>
          <td>backslash</td>
          <td>反斜线</td>
          <td>92</td>
      </tr>
  </tbody>
</table>
<p>使用 <code>TYPE</code> 可打印 <code>( c-addr u )</code> 二元组对应的字符串。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">TYPE	</span><span class="c1">( c-addr u -- )</span>		<span class="c1">\ 打印 ( c-addr u ) 二元组对应的字符串。
</span></span></span></code></pre></div><p>打印带长度的字符串可以使用 <code>COUNT TYPE</code>。</p>
<h3 id="基本的字符串操作">基本的字符串操作</h3>
<p>最基本的对字符串（也就是一段内存）操作的词有：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">MOVE	</span><span class="c1">( addr1 addr2 u -- )</span>	<span class="c1">\ 从 addr1 向 addr2 搬移 u 字节的内容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">FILL	</span><span class="c1">( c-addr u char -- )</span> 	<span class="c1">\ 将 c-addr 开始的 u 个字节的值设置为 char。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">ERASE	</span><span class="c1">( c-addr u -- )</span>			<span class="c1">\ 将 c-addr 开始的 u 个字节的值设置为 0。
</span></span></span></code></pre></div><p><code>ERASE</code> 在前面已经介绍过。<code>MOVE</code> 保证搬移之后 addr2 开始的 u 字节的内容与搬移之前 addr1 开始的 u 字节的内容相同。</p>
<p>依次处理字符串中的每一个字符时，可以用 <code>BOUNDS</code> 来将 <code>( c-addr u )</code> 二元组转换成适合 <code>DO</code> 或 <code>?DO</code> 使用的格式。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="nf">BOUNDS</span>	<span class="c1">( addr u –- addr+u addr )</span>	<span class="c1">\ 将首地址和长度转换为适合 do 或 ?do 使用的格式。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>									<span class="c1">\ bounds 可以这么定义：: bounds  over + swap ;
</span></span></span></code></pre></div><p>Forth 2012 标准中扩展的 String 词集还提供了诸如字符串比较（<code>COMPARE</code>）和查找（<code>SEARCH</code>）的词。它们都要求 <code>( c-addr u )</code> 二元组作为输入。详情请参见<a href="https://forth-standard.org/standard/string">标准原文</a>或 <em>Forth Programmer&rsquo;s Handbook 3rd ed</em> 第三章。</p>
<h3 id="对输入流的操作">对输入流的操作</h3>
<p>诸如 <code>CREATE</code>、<code>CONSTANT</code>、<code>VARIABLE</code>、<code>'</code>、<code>:</code> 等以及 <code>S&quot;</code>、<code>S\&quot;</code> 、<code>.&quot;</code> 等词从输入流中获取内容。第一组词获取输入流中的下一个记号（以空白字符分隔），第二组词获取从词后面的（单个）空白字符之后的第一个字符开始，直至下一个 <code>&quot;</code> 的内容。</p>
<p>对输入流进行基本操作的词如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">PARSE </span><span class="nf">string&lt;char&gt;</span>	<span class="c1">( char -- c-addr u )</span>	<span class="c1">\ 获取 PARSE 之后（间隔一个空格）的 string 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>											<span class="c1">\ 的内容，直到出现一个 char 字符。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>											<span class="c1">\ 将 string 对应的 ( c-addr u ) 二元组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>											<span class="c1">\ （一般直接指向输入流缓冲区内的位置）压栈。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">PARSE-NAME </span><span class="nf">string</span>	<span class="c1">( -- c-addr u )</span>			<span class="c1">\ 首先忽略 string 前导的所有连续空白；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>											<span class="c1">\ 然后获取 string 的内容，直到出现一个空白。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>											<span class="c1">\ 将 string 对应的 ( c-addr u ) 二元组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>											<span class="c1">\ （一般直接指向输入流缓冲区内的位置）压栈。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">WORD </span><span class="nf">string&lt;char&gt;</span>	<span class="c1">( char -- c-addr )</span>		<span class="c1">\ 首先忽略 string 前导的所有连续的 char 字符；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>											<span class="c1">\ 然后获取第一个非 char 字符开始直至
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>											<span class="c1">\ 下一个 char 字符之前的内容，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>											<span class="c1">\ 生成一个地址为 c-addr 的带长度的字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>											<span class="c1">\ （一般放在固定的缓冲区中）。
</span></span></span></code></pre></div><p><code>PARSE</code> 、<code>PARSE-NAME</code> 和 <code>WORD</code><sup id="fnref:28"><a href="#fn:28" class="footnote-ref" role="doc-noteref">28</a></sup> 的具体行为可以参考下面的例子<sup id="fnref:29"><a href="#fn:29" class="footnote-ref" role="doc-noteref">29</a></sup>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">char </span><span class="nf">&#34;</span> <span class="k">parse </span><span class="nf">test&#34;</span> <span class="nf">type↵</span> <span class="nf">test</span> <span class="nf">ok</span>						<span class="c1">\ 冒号定义中需要用 [char] &#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">char </span><span class="nf">&#34;</span> <span class="k">parse </span>     <span class="nf">test&#34;</span> <span class="nf">type↵</span>      <span class="nf">test</span> <span class="nf">ok</span>				<span class="c1">\ 保留了前面的 5 个空格
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">char </span><span class="nf">&#34;</span> <span class="k">parse </span>  <span class="nf">test</span>   <span class="nf">&#34;</span> <span class="nf">type↵</span>   <span class="nf">test</span>    <span class="nf">ok</span>				<span class="c1">\ 保留了前面的 2 个空格
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>														<span class="c1">\ 和后面的 3 个空格
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">char </span><span class="nf">&#34;</span> <span class="k">parse </span><span class="nf">&#34;&#34;&#34;&#34;test&#34;</span> <span class="nf">type↵</span>  <span class="nf">?</span> <span class="nf">unknown</span> <span class="k">word </span><span class="nf">&#34;&#34;&#34;test&#34;</span>	<span class="c1">\ 遇到第一个 &#34; 就停止解析了，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>														<span class="c1">\ 后面的内容被当作词处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">char </span><span class="nf">&#34;</span> <span class="k">parse </span> <span class="nf">&#34;&#34;&#34;test&#34;</span> <span class="nf">type↵</span>  <span class="nf">?</span> <span class="nf">unknown</span> <span class="k">word </span><span class="nf">&#34;&#34;test&#34;</span>	<span class="c1">\ 遇到第一个 &#34; 就停止解析了，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>														<span class="c1">\ 后面的内容被当作词处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">bl parse </span>       <span class="nf">test</span>     <span class="nf">type↵</span>  <span class="nf">?</span> <span class="nf">unknown</span> <span class="k">word </span><span class="nf">test</span>	<span class="c1">\ BL PARSE 不会忽略前导连续空白
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">parse-name </span>    <span class="nf">test</span>  <span class="nf">type↵</span> <span class="nf">test</span> <span class="nf">ok</span>			<span class="c1">\ PARSE-NAME 会忽略前导和后面的连续空白
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">bl word </span>       <span class="nf">test</span>      <span class="k">count </span><span class="nf">type↵</span> <span class="nf">test</span> <span class="nf">ok</span>	<span class="c1">\ BL WORD 也会忽略前导和后面的连续空白
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">char </span><span class="nf">&#34;</span> <span class="k">word </span><span class="nf">test&#34;</span> <span class="k">count </span><span class="nf">type↵</span> <span class="nf">test</span> <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="k">char </span><span class="nf">&#34;</span> <span class="k">word </span>  <span class="nf">test&#34;</span> <span class="k">count </span><span class="nf">type↵</span>   <span class="nf">test</span> <span class="nf">ok</span>				
</span></span><span class="line"><span class="cl"><span class="k">char </span><span class="nf">&#34;</span> <span class="k">word </span>       <span class="nf">test&#34;</span> <span class="k">count </span><span class="nf">type↵</span>        <span class="nf">test</span> <span class="nf">ok</span>	<span class="c1">\ CHAR &#34; WORD 没有忽略前导空白
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">char </span><span class="nf">&#34;</span> <span class="k">word </span><span class="nf">&#34;&#34;&#34;&#34;&#34;test&#34;</span> <span class="k">count </span><span class="nf">type↵</span> <span class="nf">test</span> <span class="nf">ok</span>				<span class="c1">\ 但忽略了前导的多个 &#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">char </span><span class="nf">&#34;</span> <span class="k">word </span> <span class="nf">&#34;&#34;&#34;&#34;test&#34;</span> <span class="k">count </span><span class="nf">type↵</span>  <span class="nf">?</span> <span class="nf">unknown</span> <span class="k">word </span><span class="nf">&#34;&#34;&#34;test&#34;</span>	<span class="c1">\ 遇到第一个 &#34; 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>																<span class="c1">\ 就停止解析了，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>																<span class="c1">\ 后面的内容被当作词处理
</span></span></span></code></pre></div><p>可以看出， <code>PARSE-NAME</code> 忽略前导空白的行为和 <code>BL WORD</code> 一致，适用于本节开始举例的第一组词（取得下一个记号的场合）；<code>PARSE</code> 适用于本节开始举例的第二组词（取得以 <code>&quot;</code> 等字符结尾的字符串的场合）。</p>
<p>下面例子中定义的词 <code>,&quot;</code> 将一个带长度的字符串存入当前堆地址。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">,&#34;</span> <span class="c1">( -- )</span>	<span class="c1">\ Compile the following string terminated by &#34; as a counted string at HERE.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">[char] </span><span class="nf">&#34;</span> <span class="k">parse	</span>	<span class="c1">\ 获得以 &#34; 结尾的字符串的二元组 ( c-addr u )
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">dup c,	</span>			<span class="c1">\ 将字符串长度 u 存入堆中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">here	</span><span class="c1">( c-addr u here )</span> <span class="k">swap </span><span class="c1">( c-addr here u )</span> 
</span></span><span class="line"><span class="cl">   <span class="k">dup </span><span class="c1">( c-addr here u u )</span> <span class="k">allot </span><span class="c1">\ allocate u bytes ( c-addr here u ) 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">move	</span>		<span class="c1">\ 将 u 个字符从 c-addr 复制到 allot 之前的 here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">;	</span>			<span class="c1">\ （也就是字串第一个字符的地址）。
</span></span></span></code></pre></div><h3 id="将字符串转换为数字">将字符串转换为数字</h3>
<p><code>&gt;NUMBER</code> 用于将字符串转换为数字。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">&gt;NUMBER	</span><span class="c1">( ud1 c-addr1 u1 -- ud2 c-addr2 u2 )</span>	
</span></span><span class="line"><span class="cl">		<span class="c1">\ 将一个包含数字的字符串 ( c-addr1 u1 ) 转换为数字。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">\ c-addr1 指向要转换的数字的最左边一位（最高位）。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">\ &gt;NUMBER 循环执行下列运算：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">\   ud1=ud1*BASE+当前位的数字; c-addr1=c-addr1+1; u1=u1-1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">\   直到遇到第一个非数字的字符或 u1=0。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">\ 转换完成后，c-addr2 指向转换完成的数字右边第一个非数字的字符，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">\ u2 包含字符串中尚未转换的字符数目。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">\ 如果整个字符串都转换了，则 c-addr2 指向整个字符串右边第一个字符，u2=0。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">\ &gt;NUMBER 只能转换无符号数字；ud1 在转换前一般设置为 0。		
</span></span></span></code></pre></div><p>例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">0</span><span class="k">. </span><span class="s">s&#34;</span> <span class="s">1234</span><span class="nf">&#34;</span> <span class="k">&gt;number cr </span><span class="s">.&#34;</span> <span class="s">u2:</span><span class="nf">&#34;</span> <span class="k">. </span><span class="s">.&#34;</span> <span class="s">c-addr2:</span><span class="nf">&#34;</span> <span class="k">u. </span><span class="s">.&#34;</span> <span class="s">num:</span><span class="nf">&#34;</span> <span class="nf">d.↵</span>
</span></span><span class="line"><span class="cl"><span class="nf">u2:0</span> <span class="nf">c-addr2:33847</span> <span class="nf">num:1234</span>  <span class="nf">ok</span>		<span class="c1">\ 字符串完全转换的情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">0</span><span class="k">. </span><span class="s">s&#34;</span> <span class="s">123456abc</span><span class="nf">&#34;</span> <span class="k">&gt;number cr </span><span class="s">.&#34;</span> <span class="s">u2:</span><span class="nf">&#34;</span> <span class="k">. </span><span class="s">.&#34;</span> <span class="s">c-addr2:</span><span class="nf">&#34;</span> <span class="k">u. </span><span class="s">.&#34;</span> <span class="s">num:</span><span class="nf">&#34;</span> <span class="nf">d.↵</span>
</span></span><span class="line"><span class="cl"><span class="nf">u2:3</span> <span class="nf">c-addr2:33849</span> <span class="nf">num:123456</span>  <span class="nf">ok</span>	<span class="c1">\ 字符串未完全转换的情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">33849</span> <span class="mi">3</span> <span class="nf">type↵</span> <span class="nf">abc</span> <span class="nf">ok</span>				<span class="c1">\ 剩余未转换的部分
</span></span></span></code></pre></div><h2 id="输入与输出">输入与输出</h2>
<p>常用的与标准输入输出有关的词如下。其中部分词在前面已经出现过。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">.	</span><span class="c1">( n -- )</span>		<span class="c1">\ 按单精度有符号整数打印栈顶的单元
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">?</span>	<span class="c1">( a-addr -- )</span>	<span class="c1">\ 按单精度有符号整数打印 a-addr 内存地址存储的数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">\ ? 可这样定义：: ?  @ . ; 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">U.	</span><span class="c1">( u -- )</span>		<span class="c1">\ 按单精度无符号整数打印栈顶的单元
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">D.	</span><span class="c1">( d -- )</span>		<span class="c1">\ 按双精度有符号整数打印栈顶的2个单元
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">.R	</span><span class="c1">( n1 n2 -- )</span>	<span class="c1">\ 打印单精度有符号整数 n1，宽度为 n2，右对齐
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">U.R	</span><span class="c1">( u n -- )</span>		<span class="c1">\ .R 的无符号版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">D.R </span><span class="c1">( d n -- )</span>		<span class="c1">\ .R 的双精度版
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">EMIT </span><span class="c1">( n -- )</span>		<span class="c1">\ 打印栈顶元素对应 ASCII 码的字符。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SPACE </span><span class="c1">( -- )</span>		<span class="c1">\ 打印一个空格。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SPACES	</span><span class="c1">( n -- )</span>	<span class="c1">\ 打印 n 个空格。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">CR	</span><span class="c1">( -- )</span>			<span class="c1">\ 打印一个回车。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">PAGE	</span><span class="c1">( -- )</span>		<span class="c1">\ 清屏。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">AT-XY	</span><span class="c1">( x y -- )</span>	<span class="c1">\ 将光标定位到 (col=x,row=y) 位置。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s">.&#34;</span> <span class="s">string</span><span class="nf">&#34;</span>	<span class="c1">( -- )</span>	<span class="c1">\ 打印跟在后面，直到下一个 `&#34;` 的字符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">.</span><span class="c1">( string)</span>	<span class="c1">( -- )</span>	<span class="c1">\ 打印跟在后面，直到下一个 `)` 的字符。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">\ `.(` 为立即词，在编译时使用也会立刻打印出后面的字符，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">\ 常用于需要将程序中间的注释打印出来的场合。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">KEY </span><span class="c1">( -- n )</span>		<span class="c1">\ 等待标准输入，并返回按下的按键的 ASCII 码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">ACCEPT </span><span class="c1">( c-addr +n1 -- +n2 )</span>	<span class="c1">\ 从标准输入获得最多 +n1 个字符并回显
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>								<span class="c1">\ （可提供行编辑功能），以回车结束。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>								<span class="c1">\ 获得的字符存储在 c-addr 开始的缓冲区，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>								<span class="c1">\ 实际获得的字符数为 +n2。
</span></span></span></code></pre></div><h3 id="数字的格式化输出pictured-numeric-output">数字的格式化输出（pictured numeric output）</h3>
<p>使用下面的词按一定的格式输出数字：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">&lt;#	</span><span class="c1">( ud -- ud )</span> <span class="nf">|</span> <span class="c1">( n ud -- n ud )</span>	<span class="c1">\ 初始化输出缓冲区。ud 为要输出的数字；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>									<span class="c1">\ 如果要输出正负号，则需要在栈内保留含有符号的值 n。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">#	</span><span class="c1">( ud1 -- ud2 )</span>	<span class="c1">\ 将 ud1 除以 BASE，商为 ud2，余数放入输出缓冲区。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">#S	</span><span class="c1">( ud1 -- ud2 )</span>	<span class="c1">\ 连续执行 #，直到商 ud2 为 0。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SIGN	</span><span class="c1">( n -- )</span>	<span class="c1">\ 如果 n 为负数，则将一个负号 `-` 放入输出缓冲区。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">HOLD	</span><span class="c1">( c -- )</span>	<span class="c1">\ 将字符 c 放入输出缓冲区。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">HOLDS</span>	<span class="c1">( c-addr u --)</span>	<span class="c1">\ 将 ( c-addr u ) 二元组指示的字符串放入输出缓冲区。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">#&gt;	</span><span class="c1">( ud -- c-addr u )</span>	<span class="c1">\ 结束格式化输出。丢掉栈内的 ud，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>						<span class="c1">\ 将输出缓冲区的 ( c-addr u ) 二元组放入栈中。
</span></span></span></code></pre></div><p>注意 <code>#</code>、<code>#S</code>、<code>SIGN</code>、<code>HOLD</code> 和 <code>HOLDS</code> 只能在 <code>&lt;#</code>&hellip;<code>#&gt;</code> 中间使用。</p>
<p>一般情况下，可以这样为格式化输出准备栈的内容：</p>
<table>
  <thead>
      <tr>
          <th>需要输出的数字</th>
          <th>准备方法</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>无符号单精度整数</td>
          <td><code>0</code> （<code>#</code> 等词需要双精度整数，用 <code>0</code> 补齐高 16 位）</td>
      </tr>
      <tr>
          <td>有符号单精度整数</td>
          <td><code>DUP ABS 0</code></td>
      </tr>
      <tr>
          <td>无符号双精度整数</td>
          <td>（不需要特别准备）</td>
      </tr>
      <tr>
          <td>有符号双精度整数</td>
          <td><code>SWAP OVER DABS</code></td>
      </tr>
  </tbody>
</table>
<p>输出单精度有符号整数的 <code>.</code> 可这样定义：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">.</span> <span class="c1">( n -- )</span>
</span></span><span class="line"><span class="cl">   <span class="k">dup abs </span><span class="mi">0</span>	<span class="c1">( n ud=|n| -- )</span>
</span></span><span class="line"><span class="cl">   <span class="k">&lt;#
</span></span></span><span class="line"><span class="cl"><span class="k"></span>      <span class="k">#s	</span>	<span class="c1">\ 将数字放入输出缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">rot sign	</span><span class="c1">\ 将 n 转移到栈顶，然后获取 n 的符号，如果 n 为负，将 `-` 放入输出缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">#&gt;
</span></span></span><span class="line"><span class="cl"><span class="k"></span>   <span class="k">type space ;	</span><span class="c1">\ 打印输出缓冲区的内容，并打印一个空格
</span></span></span></code></pre></div><p>注意输出的内容是<strong>从右往左</strong>依次处理的，而 <code>&lt;#</code>&hellip;<code>#&gt;</code> 中间的处理词是<strong>从左往右</strong>依次排列的。</p>
<p>如果要至少输出 3 位数字，则可用下面的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">.nnn</span> <span class="c1">( n -- )</span> <span class="k">dup abs </span><span class="mi">0</span>  <span class="k">&lt;# # # #s rot sign #&gt; </span> <span class="k">type space ;
</span></span></span></code></pre></div><p>注意 <code>#S</code> 至少会输出一位数字，所以此处只需要两个 <code>#</code>。输出的效果如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">0</span> <span class="kt">.</span><span class="nf">nnn↵</span> <span class="mi">000</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">-1</span> <span class="kt">.</span><span class="nf">nnn↵</span> <span class="mi">-001</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">1000</span> <span class="kt">.</span><span class="nf">nnn↵</span> <span class="mi">1000</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">-1000</span> <span class="kt">.</span><span class="nf">nnn↵</span> <span class="mi">-1000</span>  <span class="nf">ok</span>
</span></span></code></pre></div><p>使用格式化输入输出的方法，可以方便地输出<strong>定点数</strong>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">d.$</span> <span class="c1">( d -- )</span> <span class="k">swap over dabs </span>
</span></span><span class="line"><span class="cl">   <span class="k">&lt;# # # [char] . hold #s rot sign [char] </span><span class="nf">$</span> <span class="k">hold #&gt; </span> <span class="k">type space ;
</span></span></span></code></pre></div><p>其中，<code># #</code> 输出两位小数，<code>[char] . hold</code> 输出小数点，<code>#s</code> 输出整数部分，<code>rot sign</code> 输出负号（如有），<code>[char] $ hold</code> 输出货币符号。</p>
<p>实际的输出例子如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">-123456</span><span class="k">. </span><span class="nf">d.$↵</span> <span class="nf">$-1234.56</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">78900</span><span class="k">. </span><span class="nf">d.$↵</span> <span class="mh">$789</span><span class="kt">.00</span>  <span class="nf">ok</span>
</span></span></code></pre></div><p>与 C 语言的 <code>printf()</code> 的格式化输出字符串不同，<code>&lt;#</code>&hellip;<code>#&gt;</code> 中间可以使用其他的词进行运算、逻辑判断和分支循环等，这提供了最大的灵活性。如下面的程序实现了每三位数字加一个逗号：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">&#39;,&#39;</span>  <span class="k">[char] , hold ;	</span><span class="c1">\ 输出一个逗号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">:</span> <span class="nc">d.eng</span> <span class="c1">( d -- )</span> <span class="k">swap over dabs </span><span class="mi">0</span> <span class="k">&gt;r	</span><span class="c1">\ 用返回栈暂存处理到哪一位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">&lt;# begin
</span></span></span><span class="line"><span class="cl"><span class="k"></span>      <span class="k"># r&gt; 1+ &gt;r	</span>					<span class="c1">\ 每输出 1 位，加 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">2dup d0= 0= while	</span>				<span class="c1">\ 如果 # 留下的数字不为 0，则继续循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">r@ </span><span class="mi">3</span> <span class="k">mod 0= if </span><span class="nf">&#39;,&#39;</span> <span class="k">then	</span>		<span class="c1">\ 每 3 位输出一个逗号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">repeat rot sign #&gt; </span>					<span class="c1">\ 输出负号（如有）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="nf">rdrop</span> <span class="k">type space ;	</span><span class="c1">\ 最后不要忘了丢掉返回栈中的暂存数据   
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">10000</span><span class="k">. </span><span class="nf">d.eng↵</span> <span class="mi">10</span><span class="nf">,000</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">-1000001</span><span class="k">. </span><span class="nf">d.eng↵</span> <span class="mi">-1</span><span class="nf">,000,001</span>  <span class="nf">ok</span>
</span></span></code></pre></div><p>如果想在数字大于等于 0 的时候输出正号，只需使用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">+-sign</span> <span class="c1">( n -- )</span>
</span></span><span class="line"><span class="cl">   <span class="k">0&lt; if
</span></span></span><span class="line"><span class="cl"><span class="k"></span>      <span class="k">[char] - hold
</span></span></span><span class="line"><span class="cl"><span class="k"></span>   <span class="k">else
</span></span></span><span class="line"><span class="cl"><span class="k"></span>      <span class="k">[char] + hold
</span></span></span><span class="line"><span class="cl"><span class="k"></span>   <span class="k">then ; </span> 
</span></span></code></pre></div><p>注意上面定义的 <code>+-SIGN</code>  与 <code>SIGN</code> 对栈的作用完全相同，因此可直接替换 <code>SIGN</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">+-.</span>  <span class="k">dup abs </span><span class="mi">0</span> <span class="k">&lt;# #s rot </span><span class="nf">+-sign</span> <span class="k">#&gt; type space </span><span class="nf">;↵</span>  <span class="nf">ok</span>	<span class="c1">\ 与前面定义的 `.` 几乎完全相同，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>														<span class="c1">\ 除了把 sign 换为 +-sign 之外
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">100</span> <span class="nf">+-.↵</span> <span class="mi">+100</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">-100</span> <span class="nf">+-.↵</span> <span class="mi">-100</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">0</span> <span class="nf">+-.↵</span> <span class="mi">+0</span>  <span class="nf">ok</span>
</span></span></code></pre></div><h3 id="对输入的处理">对输入的处理</h3>
<p>下面的词用于对输入的处理，常用于解释器自身<sup id="fnref:30"><a href="#fn:30" class="footnote-ref" role="doc-noteref">30</a></sup>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">&gt;IN	</span>	<span class="c1">( -- a-addr )</span> 	<span class="c1">\ a-addr 中存储输入缓冲区当前处理的位置。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SOURCE	</span><span class="c1">( -- c-addr u )</span>	<span class="c1">\ 返回输入缓冲区的地址 c-addr 和其中的字符数 u。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SOURCE-ID	</span><span class="c1">( -- n )</span>	<span class="c1">\ 返回 0 表示输入流是标准输入；1 表示输入流是 EVALUATE 的字符串。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">EVALUATE	</span><span class="c1">( c-addr u --)</span>	<span class="c1">\ 将字符串 ( c-addr u ) 作为输入流进行解释。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">QUIT	</span>	<span class="c1">( ... -- )</span>		<span class="c1">\ 停止当前程序的执行，清空栈和返回栈，设置输入为标准输入，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="c1">\ 回到立即模式，等待用户输入。QUIT 不打印提示符。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">FIND	</span>	<span class="c1">( c-addr -- c-addr 0 | xt 1 | xt -1 )</span> <span class="c1">\ 从字典中查找词。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">\ 被查找的词是地址为 c-addr 的带长度的字符串。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">\ 如果没有找到，则返回 c-addr 0；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">\ 如果找到了，则返回对应词的 xt 和 1/-1。1 代表词为立即词，-1 代表词为普通词。
</span></span></span></code></pre></div><h2 id="块操作">块操作</h2>
<p>运行在操作系统之上的 Forth 系统可以借助操作系统的强大威力进行文件操作；但对于 My4TH Forth 这种运行在裸机上的简单 Forth 系统，一般使用<strong>块</strong>（block）的方式来组织非挥发性的外部存储器。</p>
<p>块是 1024 字节大小的外部存储区域，用块号寻址。<code>My4TH</code> 最多挂载 512kB 的 I2C EEPROM 存储器，因此块号为 0&hellip;511。</p>
<p>块可以用来存储文本格式的程序<sup id="fnref:31"><a href="#fn:31" class="footnote-ref" role="doc-noteref">31</a></sup>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">LOAD	</span><span class="c1">( u -- )</span>		<span class="c1">\ 将块 u 的内容做为程序喂给解释器。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">THRU	</span><span class="c1">( u1 u2 -- )</span>	<span class="c1">\ 将块 u1..u2 的内容做为程序喂给解释器。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">LIST	</span><span class="c1">( u -- )</span>		<span class="c1">\ 列出块 u 的内容。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">EDIT</span>	<span class="c1">( u -- )</span>		<span class="c1">\ 启动文本编辑器，编辑块 u 的内容。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">REFILL	</span><span class="c1">( -- f )</span>		<span class="c1">\ 在块中使用时，将下一块指定为输入源。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>						<span class="c1">\ 如果成功，则 f=true，否则 f=false。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SCR	</span>	<span class="c1">( -- a-addr )</span>	<span class="c1">\ a-addr 中存储上一次用 LIST 列出的块号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">BLK	</span>	<span class="c1">( -- a-addr )</span>	<span class="c1">\ a-addr 中存储当前用作解释器输入的块号。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>						<span class="c1">\ 如果解释器的输入不是块，则 BLK=0。
</span></span></span></code></pre></div><p>存储文本时，一般将块组织为 16 行，每行 64 个字节<sup id="fnref:32"><a href="#fn:32" class="footnote-ref" role="doc-noteref">32</a></sup>。这样的一块文本也称作一<strong>屏</strong>（screen）。变量 <code>SCR</code> 存储上一次列出的屏号。</p>
<p>由于 <code>BLK=0</code> 用于指示解释器的输入流不来自块，块 0 不能用作解释器的输入，也就是不能 <code>LOAD</code> 或 <code>THRU</code>。这一块一般用于存储简要的文档信息（比如后面的块的分配情况或者叫“目录”）。My4TH Forth 中，块 0 的最前面一行的开头如果有一个数字，那么系统复位时，会 <code>LOAD</code> 数字对应的块的内容。</p>
<p>Forth 系统可在内存中开辟若干个大小为 1 个块的<strong>块缓冲区</strong>（block buffer），用于临时存储正在处理的块。有些系统中采用多个块缓冲区；My4TH Forth 采用最简单的实现方案：单个块缓冲区，在需要时分配<sup id="fnref:33"><a href="#fn:33" class="footnote-ref" role="doc-noteref">33</a></sup>。</p>
<p>对块缓冲区进行操作的词如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">BLOCK	</span>		<span class="c1">( u -- a-addr )</span>	<span class="c1">\ 将块 u 的内容读入 a-addr 开始的块缓冲区。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">BUFFER	</span>		<span class="c1">( u -- a-addr )</span>	<span class="c1">\ 设定块号 u，需要时分配块缓冲区，但不读入内容。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">UPDATE	</span>		<span class="c1">( -- )</span>			<span class="c1">\ 将正在处理的块标记为“已改动”。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">FLUSH	</span>		<span class="c1">( -- )</span>			<span class="c1">\ 将已改动的块写入非挥发性存储器，可能时释放块缓冲区。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SAVE-BUFFERS	</span><span class="c1">( -- )</span>			<span class="c1">\ 将已改动的块写入非挥发性存储器，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>								<span class="c1">\ 清除 UPDATE 使用的标志，不释放块缓冲区。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">EMPTY-BUFFERS	</span><span class="c1">( -- )</span>			<span class="c1">\ 放弃已改动的块，可能时释放块缓冲区。
</span></span></span></code></pre></div><p>若当前正在处理的块标记为已改动，<code>BLOCK</code> 和 <code>BUFFER</code> 在进行下一步操作前，会将当前块写入非挥发性存储器，然后再处理新块的内容。</p>
<p>下面是块操作的两个例子。</p>
<p>My4TH Forth 只会分配一个块缓冲区。因此将一个块复制到另一个块的程序特别简单：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">cp</span> <span class="c1">( src dst -- )</span>
</span></span><span class="line"><span class="cl">   <span class="k">swap </span>		<span class="c1">( dst src -- )</span>
</span></span><span class="line"><span class="cl">   <span class="k">block drop </span>	<span class="c1">( dst -- )</span>	<span class="c1">\ 将块 src 的内容读入块缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">buffer drop	</span><span class="c1">( -- )</span>		<span class="c1">\ 将块号设置为 dst。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>							<span class="c1">\ 由于块缓冲区只有一个，现在其内容是块 src 的内容。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">update </span>		<span class="c1">\ 将块 dst 标记为已改动
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">flush ;	</span>	<span class="c1">\ 将块 dst 写入非挥发性存储器
</span></span></span></code></pre></div><p>如果需要标明一屏（或连续几屏）程序的用途，可以使用一屏的最前面一行来书写注释。下面的程序可以列出所有位于某屏的最前面一行并以 <code>\ C</code> 开头的注释：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">dcat</span> <span class="c1">( blk -- f )</span>
</span></span><span class="line"><span class="cl">   <span class="c1">\ 如果块 blk 的最前面一行以 `\ C` 开头，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">\ 打印块号和最前面一行中 `\ C` 后面跟着的内容，返回真；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">\ 否则不打印任何内容，返回假。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">dup </span><span class="c1">( blk blk )</span>
</span></span><span class="line"><span class="cl">   <span class="k">block </span><span class="c1">( blk a-addr )</span>
</span></span><span class="line"><span class="cl">   <span class="k">dup c@ </span><span class="mi">92</span> <span class="nf">=</span> <span class="k">if	</span>	<span class="c1">\ 如果块 blk 的第一个字符为 `\`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">dup </span><span class="mi">2</span> <span class="k">+ c@ </span><span class="mi">67</span> <span class="nf">=</span> <span class="k">if	</span><span class="c1">\ 如果块 blk 的第三个字符为 `C`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="k">swap </span><span class="c1">( a-addr blk )</span>
</span></span><span class="line"><span class="cl">         <span class="mi">4</span> <span class="k">.r	</span><span class="c1">\ 打印块号 blk，右对齐，占 4 个位置宽
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="mi">3</span> <span class="k">+ </span><span class="mi">61</span> <span class="k">type	</span><span class="c1">\ 打印最前面一行中 `\ C` 后面跟着的内容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="k">true exit	</span>	<span class="c1">\ 设置 f 为 true，退出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">then </span>
</span></span><span class="line"><span class="cl">   <span class="k">then </span>
</span></span><span class="line"><span class="cl">   <span class="k">2drop false ;	</span>	<span class="c1">\ 如果最前面一行不以 `\ C` 开头，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>						<span class="c1">\ 抛弃 blk 和 a-addr，设置 f 为 false，退出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">cat</span> <span class="c1">( from to -- )</span> <span class="c1">\ 从 from 到 to 遍历块，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">1+ swap </span><span class="c1">\ 为 do 准备栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">cr do </span>
</span></span><span class="line"><span class="cl">      <span class="mi">13</span> <span class="k">emit i </span><span class="nf">dcat</span> 		<span class="c1">\ 对块 i（从 from 到 to） 执行 dcat
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if cr else i . then	</span><span class="c1">\ 如果块 i 的最前面一行以 `\ C` 开头，另起一新行，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      						<span class="c1">\ 否则回到行首，打印 i。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    						<span class="c1">\ 这样可以看到当前处理的块号。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">loop
</span></span></span><span class="line"><span class="cl"><span class="k"></span>   <span class="mi">13</span> <span class="k">emit ;	</span><span class="c1">\ 回到行首
</span></span></span></code></pre></div><h2 id="获取系统环境信息">获取系统环境信息</h2>
<p>词 <code>ENVIRONMENT?</code> 可用来获取系统环境信息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="k">ENVIRONMENT?	</span><span class="c1">( c-addr u -- false | i*x true )</span>	
</span></span><span class="line"><span class="cl">					<span class="c1">\ 输入一个字符串的 ( c-addr u ) 二元组。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">\ 输入字符串跟某个系统环境字符串匹配时，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">\ 返回对应的返回值和 true；否则返回 false。
</span></span></span></code></pre></div><p>例如，系统环境字符串 <code>MAX-N</code> 返回最大的单精度有符号整数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="s">s&#34;</span> <span class="s">max-n</span><span class="nf">&#34;</span> <span class="k">environment? </span><span class="kt">.</span><span class="nf">s↵</span> <span class="nf">&lt;2&gt;</span> <span class="mi">32767</span> <span class="mi">-1</span>  <span class="nf">ok</span>
</span></span></code></pre></div><p>标准的系统环境字符串有下面一些：</p>
<table>
  <thead>
      <tr>
          <th>字符串</th>
          <th>返回值类型</th>
          <th>意义</th>
          <th>My4TH Forth 中的值</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>/COUNTED-STRING</code></td>
          <td>n</td>
          <td>带长度的字符串的最长长度</td>
          <td>255</td>
      </tr>
      <tr>
          <td><code>/HOLD</code></td>
          <td>n</td>
          <td>数字格式化输出使用的缓冲区的大小（字符数）</td>
          <td>112</td>
      </tr>
      <tr>
          <td><code>/PAD</code></td>
          <td>n</td>
          <td>缓冲区 <code>PAD</code> 的大小（字符数）</td>
          <td>96</td>
      </tr>
      <tr>
          <td><code>ADDRESS-UNIT-BITS</code></td>
          <td>n</td>
          <td>一个寻址单位的位数<sup id="fnref:34"><a href="#fn:34" class="footnote-ref" role="doc-noteref">34</a></sup></td>
          <td>8</td>
      </tr>
      <tr>
          <td><code>FLOORED</code></td>
          <td>flag</td>
          <td><code>/MOD</code> 使用下取整除法时为真，使用对称除法时为假</td>
          <td>false</td>
      </tr>
      <tr>
          <td><code>MAX-CHAR</code></td>
          <td>u</td>
          <td>最大的字符型量值</td>
          <td>255</td>
      </tr>
      <tr>
          <td><code>MAX-D</code></td>
          <td>d</td>
          <td>最大的双精度有符号整数</td>
          <td>2147483647</td>
      </tr>
      <tr>
          <td><code>MAX-N</code></td>
          <td>n</td>
          <td>最大的单精度有符号整数</td>
          <td>32767</td>
      </tr>
      <tr>
          <td><code>MAX-U</code></td>
          <td>u</td>
          <td>最大的单精度无符号整数</td>
          <td>65535</td>
      </tr>
      <tr>
          <td><code>MAX-UD</code></td>
          <td>ud</td>
          <td>最大的双精度无符号整数</td>
          <td>4294967295</td>
      </tr>
      <tr>
          <td><code>RETURN-STACK-CELLS</code></td>
          <td>n</td>
          <td>返回栈的最大深度（以单元数为单位）</td>
          <td>50</td>
      </tr>
      <tr>
          <td><code>STACK-CELLS</code></td>
          <td>n</td>
          <td>栈的最大深度（以单元数为单位）</td>
          <td>128</td>
      </tr>
  </tbody>
</table>
<h2 id="进一步的读物及参考文献">进一步的读物及参考文献</h2>
<p>下面是 Forth 2012 的参考资料。</p>
<p><a href="https://www.forth.com/product/forth-application-techniques/">Forth Application Techniques 6th ed</a>：篇幅很短的入门教程。</p>
<p><a href="https://www.forth.com/product/forth-programmers-handbook/">Forth Programmer&rsquo;s Handbook 3rd ed</a>：比较全面的参考手册。</p>
<p><a href="https://forth-standard.org/">Forth 2012 Standard</a>：标准全文。</p>
<p><a href="https://github.com/qiwenmin/t4th">t4th</a>：使用 Python 实现的简单 Forth 系统。完整实现了 Core 和 Core Extension 词集，能够通过标准的测试用例。</p>
<p>下面是 Forth 2012 标准制定之前的资料。</p>
<p><a href="https://dl.acm.org/doi/10.5555/5709">FORTH: a Text and Reference</a>：Forth-79/83 时代的一本非常全面的参考书。</p>
<p><a href="https://www.forth.org/Ting/ForthNotebook-1986.zip">C. H. Ting&rsquo;s Forth Notebook vol.1</a> <a href="https://www.forth.org/Ting/ForthNotebook-Volume2-1987.zip">vol.2</a>: 很多实际的例子。</p>
<p><a href="https://dl.acm.org/doi/10.5555/26942">Library of Forth routines and utilities</a>：更多实际的例子。</p>
<p><a href="https://galileo.phys.virginia.edu/classes/551.jvn.fall01/primer.htm">A Beginner&rsquo;s Guide to Forth (J. V. Noble)</a>：一篇非常紧凑的教程（以 Win32Forth 为例）。</p>
<p><a href="https://book.douban.com/subject/26684185/">Forth 语言教程（张怀宁等）</a>：一本全面介绍 Forth-83 的中文参考书。</p>
<p><a href="https://www.forth.org/">Forth Interest Group</a>：FIG（Forth Interest Group）的网站。FIG 作为一个组织已经不再活动，但是他们的网站保留了下来。</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>致体系结构爱好者：这里的栈只要能后进先出就可以，不必须在系统内存中。事实上很多体系结构里栈都用硬件实现。&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>a. 大部分情况下，“词”这个术语可以指定义的名称，也可以指定义本身。比如可以说“执行一个词（execute a word）”或“词的名称（name of a word）”。请根据上下文判断具体所指。</p>
<p>b. 有一些中文的 Forth 文献将 word 称为“字”。为避免与CPU的机器字（英文也称为 word）混淆，本文一律将其称为“词”。在 16、32 及 64 位机的 Forth 系统中，栈中单元的大小往往与机器字长一致。</p>
<p>c. Forth 2012 标准中称一组具有类似特征的词为<strong>词集</strong>（word set）。最基本的词集有 Core 和 Core Extension 两个。标准中规定的附加词集尚有 Block、Double-Number、String、Facility、File-Access、Floating-Point 等。一个完整的 Forth 系统至少应实现 Core 词集，可以选择性实现其他词集。My4TH Forth 在 ROM 中实现了 Core、Core Extension、Block 和 Double-Number 四个基本的词集，并提供了若干实现了其他词集的模块。</p>
<p>d. 有些 Forth 文献将程序设计语言的术语“记号（token）”，也就是 Forth 解释器处理的基本单位——用空白字符分隔的、内部不含空白字符的字符串，也称作“词”。这符合“词”的日常定义。但为了减少“词”这个词的语义负担，本文使用“记号”这一说法。Forth 文献中尚有 execution token 这一说法，指代表某词运行行为的数值（具体实现中，一般也就是这个词对应的机器码程序的入口地址）。这里的 token 语义与“记号”略有不同，本文将 execution token 称作“执行标记”。&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>注意：Forth 不支持冒号定义嵌套，也就是说，一个冒号定义的中间不能包含另一个冒号定义。在看过本文第二部分或任何一个 Forth 系统的源代码后，读者将会理解其原因。&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p><code>CONSTANT</code>（以及前面提到的 <code>:</code>、<code>FORGET</code> 和 <code>MARKER</code> 等词）要求输入流中的下一个记号 <code>name</code>。本文中描述这类词时，用词名称后面加 <code>name</code> 的方式。文献中有其他的表示方式，如在栈表示中用 <code>( x &quot;&lt;spaces&gt;name&quot; -- )</code> 。&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5">
<p><code>,</code> 的语义是显然的，其他更复杂的语言往往也用 <code>,</code> 分隔数据项。当然，与其他语言不同的是，Forth 中的 <code>,</code> 本身是一个词（会执行操作）而不是一个分隔符，因此，最后一项数据后面也需要有一个 <code>,</code> 。&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6">
<p>a. Forth 标准只保证 <code>CREATE</code>、<code>ALLOT</code>、<code>,</code>、<code>C,</code> 和 <code>ALIGN</code> 操作的内存空间是连续的。其他有内存分配作用的词（如 <code>VARIABLE</code>）可以在其他空间中分配内存。因此，不要使用形如 <code>variable x 1 cells allot</code> 的方式分配内存，此时 <code>x</code> 与 <code>1 cells allot</code> 分配的内存不一定连续。当然，使用单一、连续的堆空间存储所有（可以修改的）词是最简单的实现方式。My4TH Forth 使用这一实现方式。</p>
<p>b. 在 My4TH Forth 中，分配内存的过程也就是简单地使 <code>HERE</code> 增加相应字节数的过程。当然，在分配内存之前会判断剩余内存容量是否充足。&#160;<a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:7">
<p>读者可能会好奇 <code>DOES&gt;</code> 的 <code>&gt;</code> 是怎么来的。fig-forth 中相当于 <code>CREATE</code> 的词是 <code>&lt;BUILDS</code>（细节不完全一样）。<code>&lt;BUILDS</code>&hellip;<code>DOES&gt;</code> 是不是顺眼很多？&#160;<a href="#fnref:7" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:8">
<p>执行包含 <code>CREATE</code> 的词时，<code>CREATE</code> 会要求输入流中的下一个记号 name。忽略 <code>does&gt;</code> 部分，<code>4 4 array BOARD</code> 相当于 <code>4 4 create BOARD dup , * allot</code>。&#160;<a href="#fnref:8" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:9">
<p><code>My4TH Forth 1.4</code> 原始版本中，<code>M*/</code> 的中间结果为双精度整数。本站提供的固件对其进行了更改以符合标准。&#160;<a href="#fnref:9" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:10">
<p>注意分支与循环使用的词（<code>IF</code>&hellip;<code>ELSE</code>&hellip;<code>THEN</code>、<code>CASE</code>&hellip;<code>OF</code>&hellip;<code>ENDOF</code>&hellip;<code>ENDCASE</code>、<code>DO</code>&hellip;<code>LOOP</code> 等）只能在冒号定义中使用，它们对栈的作用发生在运行冒号定义时（也就是下面将要提到的<strong>执行时行为</strong>）。因此在这些词的栈表示法中标出了 <code>rt:</code>。&#160;<a href="#fnref:10" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:11">
<p>Forth 中，<code>THEN</code> 出现在整个条件分支的最后，与 BASIC 或 Lua 等使用中缀表达式的语言不同。将 Forth 的 <code>THEN</code> 理解为 END IF 也许会有助于阅读程序。&#160;<a href="#fnref:11" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:12">
<p><code>?DUP</code> 可以这样定义：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">?dup</span>	<span class="c1">( n -- n n | 0 )</span>
</span></span><span class="line"><span class="cl">   <span class="k">dup	</span>				<span class="c1">( -- n n )</span> 
</span></span><span class="line"><span class="cl">   <span class="k">if	</span>				<span class="c1">( -- n )</span>
</span></span><span class="line"><span class="cl">      <span class="k">dup	</span>			<span class="c1">\ 若 n&lt;&gt;0, 则 ( -- n n )
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">then	</span>				<span class="c1">\ 若 n=0,  则 ( -- n ), 即 ( -- 0 )
</span></span></span></code></pre></div>&#160;<a href="#fnref:12" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></li>
<li id="fn:13">
<p>a. 显然，对返回栈进行操作的词只能在冒号定义中使用。为简洁起见此处未单独标出 <code>rt:</code>。</p>
<p>b. 助记法：<code>&gt;R</code> 代表“数据去到返回栈（to-R)”，<code>R&gt;</code> 代表“数据来自返回栈（R-from）”。&#160;<a href="#fnref:13" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:14">
<p>a. My4TH Forth 中，<code>&gt;R</code> 和 <code>R&gt;</code> 操作的栈、调用的返回栈和循环使用的栈在物理上是<a href="http://mynor.org/my4th_forth.htm">三个栈</a>。因此，<em>Thinking Forth</em> 介绍的用 <code>R&gt; DROP</code> 改变控制流的技巧在 My4TH Forth 中不适用。当然为了可移植性，编写程序时仍需遵守这 4 条注意事项。</p>
<p>b. 有一些 Forth 系统支持局部变量。它们中有一些将局部变量存储在数据栈中，另一些将局部变量存储在返回栈中，还有一些将局部变量存储在第三个栈中。一般它们还会利用一个单独的指针来存储执行一个定义之前压入的参数和局部变量的分界线的位置（类似 <a href="http://ece425web.groups.et.byu.net/stable/labs/StackFrame.html">8086 下 C 语言的调用约定中使用 <code>BP</code> 指针的方法</a>）。My4TH Forth 不支持局部变量。</p>
<p>c. 程序中<strong>多定义几个简单的词</strong>，可读性往往大大优于定义一个复杂的词并使用返回栈暂存结果。当然，单纯为了把词拆分开而拆分词，会适得其反。&#160;<a href="#fnref:14" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:15">
<p>用于退出有限循环的词 <code>LEAVE</code> 不能用来退出不定循环。一个常见的场景是想要根据条件在任意一处退出 <code>BEGIN</code>&hellip;<code>AGAIN</code> 无限循环，此时可用 <code>BEGIN</code>&hellip;<code>WHILE</code>&hellip;<code>REPEAT</code> 循环代替。但 <code>BEGIN</code>&hellip;<code>WHILE</code>&hellip;<code>REPEAT</code> 不能与 <code>IF</code>&hellip;<code>ELSE</code>&hellip;<code>THEN</code> 交错：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">test</span> <span class="c1">( n -- )</span>
</span></span><span class="line"><span class="cl">   <span class="k">begin
</span></span></span><span class="line"><span class="cl"><span class="k"></span>      <span class="k">dup if
</span></span></span><span class="line"><span class="cl"><span class="k"></span>         <span class="mi">1</span> <span class="k">while	</span><span class="c1">\ 举例而已，正常写程序时不会这么写
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="k">dup .
</span></span></span><span class="line"><span class="cl"><span class="k"></span>      <span class="k">else
</span></span></span><span class="line"><span class="cl"><span class="k"></span>         <span class="s">.&#34;</span> <span class="s">else</span><span class="nf">&#34;</span> <span class="k">space .
</span></span></span><span class="line"><span class="cl"><span class="k"></span>      <span class="k">then
</span></span></span><span class="line"><span class="cl"><span class="k"></span>   <span class="k">repeat </span><span class="s">.&#34;</span> <span class="s">exit</span><span class="nf">&#34;</span> <span class="k">;
</span></span></span></code></pre></div><p>该词预期的行为是，n&lt;&gt;0 时不停循环打印 n 的值，n=0 时打印 “else”、n 的值和 “exit”。但实际执行结果为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">0</span> <span class="nf">test↵</span> <span class="k">exit </span><span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="kt">.</span><span class="nf">s↵</span> <span class="nf">&lt;1&gt;</span> <span class="mi">0</span>  <span class="nf">ok</span>		<span class="c1">\ else 分支没有执行，“exit” 也没有打印
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="nf">test↵</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="kt">...</span>	<span class="c1">\ 无限循环行为正确
</span></span></span></code></pre></div><p>如果想实现预期的行为，该词可以用 <code>BEGIN</code>&hellip;<code>WHILE</code>&hellip;<code>REPEAT</code> 循环这样编写：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">test</span> <span class="c1">( n -- )</span>
</span></span><span class="line"><span class="cl">   <span class="k">begin
</span></span></span><span class="line"><span class="cl"><span class="k"></span>      <span class="k">dup while
</span></span></span><span class="line"><span class="cl"><span class="k"></span>         <span class="k">dup .
</span></span></span><span class="line"><span class="cl"><span class="k"></span>   <span class="k">repeat </span>
</span></span><span class="line"><span class="cl">   <span class="s">.&#34;</span> <span class="s">else</span><span class="nf">&#34;</span> <span class="k">space . </span><span class="s">.&#34;</span> <span class="s">exit</span><span class="nf">&#34;</span> <span class="k">;
</span></span></span><span class="line"><span class="cl"><span class="k"></span>    
</span></span><span class="line"><span class="cl"><span class="mi">0</span> <span class="nf">test↵</span> <span class="k">else </span><span class="mi">0</span> <span class="k">exit </span><span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="k">.s </span><span class="nf">&lt;0&gt;</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="nf">test↵</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="kt">...</span>	
</span></span></code></pre></div><p>也可以用 <code>BEGIN</code>&hellip;<code>AGAIN</code> 无限循环嵌套 <code>IF</code>&hellip;<code>ELSE</code>&hellip;<code>THEN</code> 结构，在需要退出的时候用 <code>EXIT</code> 直接退出词（<strong>多定义几个简单的词</strong>的原则又适用了）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">test</span> <span class="c1">( n -- )</span>
</span></span><span class="line"><span class="cl">   <span class="k">begin
</span></span></span><span class="line"><span class="cl"><span class="k"></span>      <span class="k">dup if
</span></span></span><span class="line"><span class="cl"><span class="k"></span>         <span class="k">dup .
</span></span></span><span class="line"><span class="cl"><span class="k"></span>      <span class="k">else
</span></span></span><span class="line"><span class="cl"><span class="k"></span>         <span class="s">.&#34;</span> <span class="s">else</span><span class="nf">&#34;</span> <span class="k">space . </span><span class="s">.&#34;</span> <span class="s">exit</span><span class="nf">&#34;</span> <span class="k">exit
</span></span></span><span class="line"><span class="cl"><span class="k"></span>      <span class="k">then
</span></span></span><span class="line"><span class="cl"><span class="k"></span>   <span class="k">again ;
</span></span></span></code></pre></div><p>注意 My4TH Forth 目前的版本（v1.4）不支持 Forth 2012 标准 A.3.2.3.2 节描述的包含多于一个 <code>WHILE</code> 的 <code>BEGIN</code>&hellip;<code>WHILE</code>&hellip;<code>REPEAT</code> 循环。&#160;<a href="#fnref:15" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:16">
<p>在 My4TH Forth 以及其他大部分 Forth 系统中，解释器报错时会清空栈内所有元素。实际上不需要定义 <code>CLEAR</code> 一词，只需输入一个词典中没有的词，让解释器报错，即可清空栈内所有元素：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="kt">.</span><span class="nf">s↵</span> <span class="nf">&lt;5&gt;</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="nf">abc↵</span>  <span class="nf">?</span> <span class="nf">unknown</span> <span class="k">word </span><span class="nf">abc</span>
</span></span><span class="line"><span class="cl"><span class="kt">.</span><span class="nf">s↵</span> <span class="nf">&lt;0&gt;</span>  <span class="nf">ok</span>
</span></span></code></pre></div>&#160;<a href="#fnref:16" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></li>
<li id="fn:17">
<p>以 <code>IF</code> 为例：<code>IF</code> 会生成处理栈顶标志的代码；然而此时 <code>IF</code> 并不知道后面的 <code>ELSE</code> 或 <code>THEN</code> 在哪里，因此 <code>IF</code> 会将它生成的向后跳转指令的地址域的地址（称为<strong>未解决的向后引用</strong>（unresolved forward reference））压栈。<code>ELSE</code> 或者 <code>THEN</code> 会<strong>解决</strong>（resolve）它：将这个未解决的向后引用从栈中弹出，把要跳转到的地址填到那儿。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">test</span> <span class="k">if </span><span class="s">.&#34;</span> <span class="s">true.</span><span class="nf">&#34;</span> <span class="k">then ;
</span></span></span></code></pre></div><p>生成的代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="line"><span class="cl">9257 : 1E         PHL
</span></span><span class="line"><span class="cl">9258 : 19 0E 4A   JSR 4A0E				; 此时遇到 if
</span></span><span class="line"><span class="cl">										; $4A0E 是 if_check 子程序：判断栈顶标志真假
</span></span><span class="line"><span class="cl">925B : 16 70 92   JPF 9270     (+21)	; 执行 if 时还不知道跳转到哪里，
</span></span><span class="line"><span class="cl">										; 生成的代码可记作 JPF ????
</span></span><span class="line"><span class="cl">										; 将 ???? 的地址 $925C 压栈
</span></span><span class="line"><span class="cl">925E : 18 67 92   JMP 9267     (+9)
</span></span><span class="line"><span class="cl">9261 : 74         DB 116 ;&#39;t&#39;
</span></span><span class="line"><span class="cl">9262 : 72         DB 114 ;&#39;r&#39;
</span></span><span class="line"><span class="cl">9263 : 75         DB 117 ;&#39;u&#39;
</span></span><span class="line"><span class="cl">9264 : 65         DB 101 ;&#39;e&#39;
</span></span><span class="line"><span class="cl">9265 : 2E         DB  46 ;&#39;.&#39;
</span></span><span class="line"><span class="cl">9266 : 00         DB   0
</span></span><span class="line"><span class="cl">9267 : 01 0D 92   LD  r13  #146
</span></span><span class="line"><span class="cl">926A : 01 0C 61   LD  r12  #97
</span></span><span class="line"><span class="cl">926D : 19 3E 31   JSR 313E				; .&#34; 的打印子程序
</span></span><span class="line"><span class="cl">										; 此时遇到 then，知道了向后跳转要跳到 $9270
</span></span><span class="line"><span class="cl">										; 从栈内弹出未解决的向后跳转地址 $925C，
</span></span><span class="line"><span class="cl">										; 将 $9270 写入地址 $925C 
</span></span><span class="line"><span class="cl">										; $925B 处的 JPF 9270 这条指令现在才生成完整
</span></span><span class="line"><span class="cl">9270 : 1F         RTS
</span></span></code></pre></div><p>用栈解决向后引用的方法天然地可以处理多层嵌套。需要指出的是，解决向后引用用的栈可以是数据栈本身，也可以是一个单独的栈。标准中称这个栈为<a href="https://forth-standard.org/standard/usage#usage:controlstack">控制流栈（control-flow stack）</a>。&#160;<a href="#fnref:17" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:18">
<p>由于解释和编译工作都是由读取—求值—打印循环（read–evaluate–print loop, REPL）完成的，Forth 用户不太区分“解释器（interpreter）”与“编译器（compiler）”两个说法，它们往往指同一个东西。通常侧重交互性时倾向于说“解释器”，侧重在堆中生成内容的行为时倾向于说“编译器”。刻意避免这一区分时也可以直接说“Forth 系统（Forth system）”。&#160;<a href="#fnref:18" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:19">
<p>稍老的 Forth 文献中常见 <code>lfa</code>、<code>nfa</code>、<code>cfa</code> 和 <code>pfa</code> 等提法。它们分别是连接域地址（link field address）、名称域地址（name field address）、代码域地址（code field address）和参数域地址（parameter field address）的简称。在 My4TH Forth 中，<code>lfa</code> 对应图中 <code>link</code> 的地址,
<code>nfa</code> 对应 <code>length</code> 的地址，<code>cfa</code> 对应 <code>code</code> 的地址（也就是 <code>xt</code>），<code>pfa</code> 对应 <code>data</code> 的地址。&#160;<a href="#fnref:19" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:20">
<p><code>LITERAL</code>、<code>2LITERAL</code> 和 <code>COMPILE,</code> 等词只在编译模式下有确定的语义。在立即模式下使用这些词会创造出<strong>模糊情境</strong>（ambiguous condition）。Forth 系统处于模糊情境时的行为因具体实现而不同。在 My4TH Forth 中，这几个词在立即模式下使用时，会在 <code>HERE</code> 处<strong>迳行编译</strong>出相应的代码并分配内存空间。&#160;<a href="#fnref:20" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:21">
<p>但是与 <code>LITERAL</code> 和 <code>2LITERAL</code> 不同，<code>COMPILE,</code> 不是一个立即词。它的主要作用是用 Forth 编写 Forth 解释器的读取—求值—打印循环（read–evaluate–print loop, REPL）本身。因此精确地说，<code>COMPILE,</code> 拥有“确定语义”的条件又多套了一层：使用了 <code>COMPILE,</code> 的程序（一般是 Forth 解释器本身）在处理一个冒号定义的中间。&#160;<a href="#fnref:21" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:22">
<p>a. 如果 <code>xt</code> 对应的词不是用 <code>CREATE</code> 定义的（如用系统的 <code>CONSTANT</code>、<code>VARIABLE</code>、<code>VALUE</code> 或冒号定义的），那么 <code>&gt;BODY</code> 返回的结果无意义。</p>
<p>b. 由于 <code>CREATE</code> 创建的词的缺省行为就是返回后面紧跟的数据区域的地址，很多系统中，<code>&gt;BODY</code> 不做任何操作。当然如果要正确处理有 <code>DOES&gt;</code> 行为的 <code>CREATE</code> 创建的词，<code>&gt;BODY</code> 必须进行特殊处理。</p>
<p>c. My4TH Forth 中， <code>CREATE</code> 创建的词的程序区域固定为 13 个字节：如果没有 <code>DOES&gt;</code> 行为，这段程序将数据区域的地址装入 <code>R4</code> 寄存器（下面的反汇编结果中写作 r20 r21），然后将 <code>R4</code> 压入数据栈：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="line"><span class="cl">9255 : 1E         PHL
</span></span><span class="line"><span class="cl">9256 : 01 14 62   LD  r20  #98	; $9262 是后面紧跟的数据区域的地址（xt+13）
</span></span><span class="line"><span class="cl">9259 : 01 15 92   LD  r21  #146
</span></span><span class="line"><span class="cl">925C : 19 0E 41   JSR 410E		; $410E 的子程序将 r20 r21 包含的 16 位数据压入数据栈
</span></span><span class="line"><span class="cl">925F : 1F         RTS
</span></span><span class="line"><span class="cl">; 此时 here 的值为 $9262。$9260 $9261 两个字节占而不用。
</span></span></code></pre></div><p>这段程序共占用 11 字节，后面的 2 个字节占而不用。</p>
<p>如果有 <code>DOES&gt;</code> 行为，那么最后的 <code>RTS</code> 将替换成跳转到 <code>DOES&gt;</code> 程序段的 <code>JMP</code>，13 个字节全被占用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="kn">:</span> <span class="nc">constp</span>  <span class="k">create , </span>  <span class="k">does&gt; @ . cr </span><span class="nf">;↵</span>  <span class="nf">ok</span>	<span class="c1">\ 类似 CONSTANT，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>											<span class="c1">\ 但 DOES&gt; 行为是打印出值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">1000</span> <span class="nf">constp</span> <span class="nf">cc↵</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="nf">cc↵</span> <span class="mi">1000</span>
</span></span><span class="line"><span class="cl"> <span class="nf">ok</span>
</span></span></code></pre></div><p><code>cc</code> 和 <code>constp</code> 对应的代码为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="line"><span class="cl">cc
</span></span><span class="line"><span class="cl">9286 : 1E         PHL
</span></span><span class="line"><span class="cl">9287 : 01 14 93   LD  r20  #147			; $9293 是后面紧跟的数据区域的地址（xt+13）
</span></span><span class="line"><span class="cl">928A : 01 15 92   LD  r21  #146
</span></span><span class="line"><span class="cl">928D : 19 0E 41   JSR 410E
</span></span><span class="line"><span class="cl">9290 : 18 75 92   JMP 9275     (-27)	; $9275 是 constp 的 DOES&gt; 程序段的入口
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">constp
</span></span><span class="line"><span class="cl">926B : 1E         PHL
</span></span><span class="line"><span class="cl">926C : 19 72 69   JSR 6972 --&gt; create
</span></span><span class="line"><span class="cl">926F : 19 6B 4C   JSR 4C6B --&gt; ,
</span></span><span class="line"><span class="cl">9272 : 19 D2 63   JSR 63D2 --&gt; does&gt;
</span></span><span class="line"><span class="cl">9275 : 19 8C 4B   JSR 4B8C --&gt; @		; DOES&gt; 程序段的入口
</span></span><span class="line"><span class="cl">9278 : 19 54 4C   JSR 4C54 --&gt; .
</span></span><span class="line"><span class="cl">927B : 19 CF 4E   JSR 4ECF --&gt; cr
</span></span><span class="line"><span class="cl">927E : 1F         RTS 
</span></span></code></pre></div><p>因此，My4TH Forth 的 <code>&gt;BODY</code> 的实际实现是：固定将 <code>xt</code> 加 13。&#160;<a href="#fnref:22" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:23">
<p>使用系统自带的 <code>COMPILE,</code>，<code>$2d00 compile,</code> 生成的代码是简单的 <code>JSR xt</code> 指令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="line"><span class="cl">9250 : 19 00 2D   JSR 2D00
</span></span></code></pre></div><p>使用这一定义生成的代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="line"><span class="cl">9266 : 01 0F 2D   LD  r15  #45			; $2d 装入寄存器 r15
</span></span><span class="line"><span class="cl">										; (借用 FLAG 寄存器存储数据高八位）
</span></span><span class="line"><span class="cl">9269 : 03 00      LDA #0				; $00 装入寄存器 r14 (ACCU)
</span></span><span class="line"><span class="cl">926B : 74 0E      PHD r14				; r14 r15 压入数据栈
</span></span><span class="line"><span class="cl">										; 上面的代码对应 postpone literal
</span></span><span class="line"><span class="cl">926D : 19 58 6D   JSR 6D58 --&gt; execute	; 调用 execute
</span></span></code></pre></div><p>显然，这一定义生成的代码要比系统生成的 <code>JSR xt</code> 复杂很多，但仍然是正确的。&#160;<a href="#fnref:23" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:24">
<p><code>[COMPILE]</code> 是早期 Forth 系统的遗迹，不要在新的程序中使用。详见 Forth 2012 标准 <a href="https://forth-standard.org/standard/rationale#rat:core:POSTPONE">A.6.1.2033 节</a>。&#160;<a href="#fnref:24" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:25">
<p>在 Forth 的发展历史上，向量执行先于 <code>CASE</code> 出现。很多较早或较简单的 Forth 系统中不提供 <code>CASE</code>。&#160;<a href="#fnref:25" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:26">
<p>a. 读者也许已经意识到，词典中存储词的名称使用的就是带长度的字符串（当然长度字段的最高位被复用了，所以 <code>COUNT</code> 完之后也许还需要 <code>127 AND</code>）。</p>
<p>b. 带长度的字符串有时也称作“Pascal 风格的”字符串。熟悉 Pascal 语言的读者可能会回想起 <code>ShortString</code> 数据类型。&#160;<a href="#fnref:26" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:27">
<p>a. Forth 2012 标准的 Core 和 Core Extension 词集只规定了 <code>C&quot;</code>、<code>S&quot;</code> 和 <code>S\&quot;</code> 在编译时的行为。My4TH Forth 中，在立即模式下直接使用时，这三个词会在堆指针地址 <code>HERE</code> 处迳行编译字符串但不保留内存空间（生成的内容包括 3 个字节的跳转到字符串后的指令，以及字符串本身），然后将字符串地址或  <code>( c-addr u )</code> 二元组压栈。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="nf">hex↵</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="nf">here↵</span> <span class="k">u. </span><span class="mi">8</span><span class="nf">F18</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="c1">\ 字符串的地址是 HERE+3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s">c&#34;</span> <span class="s">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><span class="nf">&#34;↵</span> <span class="k">u. </span><span class="mi">8</span><span class="nf">F1B</span>  <span class="nf">ok</span>	
</span></span><span class="line"><span class="cl"><span class="s">c&#34;</span> <span class="s">123</span><span class="nf">&#34;</span> <span class="nf">u.↵</span> <span class="mi">8</span><span class="nf">F1B</span>  <span class="nf">ok</span>	<span class="c1">\ 内存没有被保留
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">here </span><span class="mi">10</span> <span class="nf">dump↵</span>	<span class="c1">\ 注意这儿的 10 是十六进制的
</span></span></span><span class="line"><span class="cl"><span class="c1">\ 可见带长度的字符串[3]123覆盖了第一次的一串 a。
</span></span></span><span class="line"><span class="cl"><span class="c1">\ 起头的 18 1F 8F是跳转到 $8F1F 处（也就是字符串结尾）的指令。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">8</span><span class="nf">F18:</span> <span class="mi">18</span> <span class="mi">1</span><span class="nf">F</span> <span class="mi">8</span><span class="nf">F</span> <span class="mi">03</span> <span class="mi">31</span> <span class="mi">32</span> <span class="mi">33</span> <span class="mi">61</span> <span class="mi">61</span> <span class="mi">61</span> <span class="mi">61</span> <span class="mi">61</span> <span class="mi">61</span> <span class="mi">61</span> <span class="mi">61</span> <span class="mi">61</span>  <span class="kt">....123</span><span class="nf">aaaaaaaaa</span>
</span></span><span class="line"><span class="cl"><span class="c1">\      8  9  a  b  c  d  e  ↑$8F1F
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s">s&#34;</span> <span class="s">bcd</span><span class="nf">&#34;</span> <span class="k">u. </span><span class="nf">u.↵</span> <span class="mi">3</span> <span class="mi">8</span><span class="nf">F1B</span>  <span class="nf">ok</span>	<span class="c1">\ 内存同样没有被保留
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">here </span><span class="mi">10</span> <span class="nf">dump↵</span>
</span></span><span class="line"><span class="cl"><span class="c1">\ s&#34; 生成的字符串 bcd 覆盖了上一次的字符串。长度并没有编译入内存，而是只压栈。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">8</span><span class="nf">F18:</span> <span class="mi">18</span> <span class="mi">1</span><span class="nf">E</span> <span class="mi">8</span><span class="nf">F</span> <span class="mi">62</span> <span class="mi">63</span> <span class="mi">64</span> <span class="mi">33</span> <span class="mi">61</span> <span class="mi">61</span> <span class="mi">61</span> <span class="mi">61</span> <span class="mi">61</span> <span class="mi">61</span> <span class="mi">61</span> <span class="mi">61</span> <span class="mi">61</span>  <span class="kt">...</span><span class="nf">bcd3aaaaaaaaa</span>
</span></span><span class="line"><span class="cl"><span class="nf">decimal↵</span>  <span class="nf">ok</span>
</span></span></code></pre></div><p>My4TH Forth 的这一行为方便了使用，且符合标准中 File-Access 词集对 <code>S&quot;</code> 和 <code>S\&quot;</code> 的扩展（参见标准 <a href="https://forth-standard.org/standard/rationale#rat:file:Sq">A.11.6.1.2165 节</a>）。但使用时必须要注意这一覆盖行为。如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-forth" data-lang="forth"><span class="line"><span class="cl"><span class="s">c&#34;</span> <span class="s">123</span><span class="nf">&#34;</span> <span class="k">count </span><span class="nf">type↵</span> <span class="mi">123</span> <span class="nf">ok</span>	<span class="c1">\ 打印出字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s">s&#34;</span> <span class="s">456</span><span class="nf">&#34;</span> <span class="nf">type↵</span> <span class="mi">456</span> <span class="nf">ok</span>		<span class="c1">\ 同样打印出字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s">c&#34;</span> <span class="s">123</span><span class="nf">&#34;</span> <span class="s">c&#34;</span> <span class="s">4567</span><span class="nf">&#34;</span> <span class="k">count type count </span><span class="nf">type↵</span> <span class="mi">456456</span> <span class="nf">ok</span>	<span class="c1">\ 第二次的字符串覆盖了第一次
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="s">s&#34;</span> <span class="s">123</span><span class="nf">&#34;</span> <span class="s">s&#34;</span> <span class="s">4567</span><span class="nf">&#34;</span> <span class="k">type </span><span class="nf">type↵</span> <span class="mi">4567456</span> <span class="nf">ok</span>	<span class="c1">\ 同样的覆盖行为
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl"><span class="c1">\ 如果在编译时使用 C&#34; 或 S&#34;，则字符串不会覆盖：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">:</span> <span class="nc">test1</span>  <span class="s">c&#34;</span> <span class="s">123</span><span class="nf">&#34;</span> <span class="s">c&#34;</span> <span class="s">4567</span><span class="nf">&#34;</span> <span class="k">count type count type </span><span class="nf">;↵</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="nf">test1</span> <span class="mi">4567123</span><span class="nf">↵</span> <span class="nf">ok</span>	<span class="c1">\ 符合预期的行为
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">:</span> <span class="nc">test2</span>  <span class="s">s&#34;</span> <span class="s">123</span><span class="nf">&#34;</span> <span class="s">s&#34;</span> <span class="s">4567</span><span class="nf">&#34;</span> <span class="k">type type </span><span class="nf">;↵</span>  <span class="nf">ok</span>
</span></span><span class="line"><span class="cl"><span class="nf">test2↵</span> <span class="mi">4567123</span> <span class="nf">ok</span>	<span class="c1">\ 符合预期的行为
</span></span></span></code></pre></div><p>b. <code>S&quot;</code>、<code>S\&quot;</code> 以及其他名称中带双引号的词（如<code>.&quot;</code>）的编译产物在内存中的存储格式<strong>未必是</strong>带长度的字符串。在 My4TH Forth 中， <code>S&quot;</code>、<code>S\&quot;</code> 的编译产物中不带长度（长度已存储在<code>( c-addr u )</code> 二元组的 <code>u</code> 中），<code>.&quot;</code> 的编译产物的存储格式是以 ASCII 0 结尾的（“C 风格的”）字符串。&#160;<a href="#fnref:27" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:28">
<p><code>WORD</code> 是 Forth 早期历史的遗迹。<code>WORD</code> 处理输入流需要进行低效的串拷贝工作，而且带长度的字符串的长度受到限制（最长 255），固定缓冲区的复用也需要加以特别的注意。编写新的程序时，请尽量避免使用 <code>WORD</code>（也许唯一一个需要使用 <code>WORD</code> 的场合是与 <code>FIND</code> 一起使用，常用来编写 Forth 解释器本身），而尽量使用以 <code>( c-addr u )</code> 二元组描述输入流缓冲区内字符串的 <code>PARSE</code> 和 <code>PARSE-NAME</code>。&#160;<a href="#fnref:28" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:29">
<p><code>My4TH Forth 1.4</code> 原始版本中 <code>PARSE</code> 和 <code>WORD</code> 忽略前导字符的行为与标准相反。本站提供的固件对其进行了更改以符合标准。&#160;<a href="#fnref:29" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:30">
<p>a. 由于 <code>My4TH</code> 系统使用串行运算器，计算加法较慢，故 My4TH Forth 的 <code>&gt;IN</code> 和 <code>SOURCE</code> 实现与标准不同：标准中使用“基地址加偏移量”表示法描述，系统变量 <code>&gt;IN</code> 中存储的内容是相对缓冲区起始地址的偏移量；而 My4TH Forth 中认为基地址总是 0，这样 <code>&gt;IN</code> 中存储的内容就是当前处理的字符本身的地址，<code>SOURCE</code> 返回的 c-addr 也是 0。这样可以保证行为与标准实现一致：<code>SOURCE</code> 返回的“缓冲区字符数” u 减去 <code>&gt;IN</code> 存储的内容，仍然是缓冲区中尚未处理的字符数。</p>
<p>b. <code>QUIT</code> 对应解释器等待终端输入的缺省行为（在符合标准的实现中，<strong><code>QUIT</code> <a href="https://www.forth.org/svfig/Len/Quitloop.htm">就是</a>解释器本身</strong>）。标准中只要求 <code>QUIT</code> 清空返回栈。&#160;<a href="#fnref:30" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:31">
<p>My4TH Forth 中的 <code>LOAD</code> 和 <code>THRU</code> 处理从块来的输入流时，会逐行（每 64 字节）而非逐块读取并处理非挥发性存储器中的内容。所以 <code>&gt;IN</code> 和 <code>SOURCE</code> 返回的不是块缓冲区的地址（<em>Thinking Forth</em> 中讲的跳过一屏程序的后半部分的技巧不适用）。&#160;<a href="#fnref:31" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:32">
<p>与现代操作系统中的文本文件不同，一屏文本永远只包含 16 行。每行右边不足 64 个字节的部分用 <code>BL</code> 补齐。&#160;<a href="#fnref:32" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:33">
<p>在 My4TH Forth 中，块缓冲区在堆内分配。如果分配块缓冲区之后堆内没有进行新的内存分配，则 <code>FLUSH</code> 和 <code>EMPTY-BUFFERS</code> 会释放块缓冲区；否则它们不会释放块缓冲区（因为此时释放块缓冲区会同时释放掉之后分配的元素）。&#160;<a href="#fnref:33" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:34">
<p><code>ADDRESS-UNIT-BITS</code> 应返回一个寻址单位（字节）的位数（8）。<code>My4TH Forth 1.4</code> 原始版本返回一个单元的位数（16），本站提供的固件对其进行了更改以符合标准。&#160;<a href="#fnref:34" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
</div>
    </article>
  </main>

      </div>
      <footer>
  <hr />
  
    <p id="social">
      Find me around the web:
      <br />
      
        
        <a href="mailto:bh1phl%20[at]%20hotmail.com">email</a>
      
         | 
        <a href="http://www.qrz.com/db/BH1PHL">qrz.com</a>
      
         | 
        <a href="https://qsl.net/bh1phl">qsl.net</a>
      
         | 
        <a href="https://bh1phl.github.io">github.io</a>
      
    </p>
  
  <p class="copyright">
    Copyright © 2014-2025
    <a href="/zh/"><strong>BH1PHL</strong></a>.
    Licensed under the
    <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> license unless otherwise noted.
  </p>
  <p class="builtWith">
    Built with
    <a href="http://www.gohugo.io/">Hugo</a>,
    using the theme
    <a href="https://gitlab.com/ian-s-mcb/smigle-hugo-theme">smigle</a>,
    which was influenced by the theme
    <a href="https://github.com/sumnerevans/smol">smol</a>.
  </p>
  <script>
    
    if (window.location.host !== 'qsl.net')
        window.goatcounter = {no_onload: true}
  </script>
  <script data-goatcounter="https://bh1phl.goatcounter.com/count"
    async src="https://qsl.net/bh1phl/count.js"></script>
</footer>

    </div>
  </body>
</html>
